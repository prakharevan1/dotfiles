.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Test::Future 3pm"
.TH Test::Future 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"Test::Future" \- unit test assertions for Future instances
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&   use Test::More tests => 2;
\&   use Test::Future;
\&
\&   no_pending_futures {
\&      my $f = some_function();
\&
\&      is( $f\->get, "result", \*(AqResult of the some_function()\*(Aq );
\&   } \*(Aqsome_function() leaves no pending Futures\*(Aq;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module provides unit testing assertions that may be useful when testing
code based on, or using Future instances or subclasses.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS no_pending_futures
.IX Subsection "no_pending_futures"
.Vb 1
\&   no_pending_futures( \e&code, $name );
.Ve
.PP
\&\fISince version 0.29.\fR
.PP
Runs the given block of code, while keeping track of every \f(CW\*(C`Future\*(C'\fR instance
constructed while doing so. After the code has returned, each of these
instances are inspected to check that they are not still pending. If they are
all either ready (by success or failure) or cancelled, the test will pass. If
any are still pending then the test fails.
.PP
If Devel::MAT is installed, it will be used to write a memory state dump
after a failure. It will create a \fI.pmat\fR file named the same as the unit
test, but with the trailing \fI.t\fR suffix replaced with \fI\-TEST.pmat\fR where
\&\f(CW\*(C`TEST\*(C'\fR is the number of the test that failed (in case there was more than
one). A list of addresses of \f(CW\*(C`Future\*(C'\fR instances that are still pending is
also printed to assist in debugging the issue.
.PP
It is not an error if the code does not construct any \f(CW\*(C`Future\*(C'\fR instances at
all. The block of code may contain other testing assertions; they will be run
before the assertion by \f(CW\*(C`no_pending_futures\*(C'\fR itself.
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
