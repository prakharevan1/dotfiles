.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Future::Mutex 3pm"
.TH Future::Mutex 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"Future::Mutex" \- mutual exclusion lock around code that returns Futures
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&   use Future::Mutex;
\&
\&   my $mutex = Future::Mutex\->new;
\&
\&   sub do_atomically
\&   {
\&      return $mutex\->enter( sub {
\&         ...
\&         return $f;
\&      });
\&   }
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
Most Future\-using code expects to run with some level of concurrency, using
future instances to represent still-pending operations that will complete at
some later time. There are occasions however, when this concurrency needs to
be restricted \- some operations that, once started, must not be interrupted
until they are complete. Subsequent requests to perform the same operation
while one is still outstanding must therefore be queued to wait until the
first is finished. These situations call for a mutual-exclusion lock, or
"mutex".
.PP
A \f(CW\*(C`Future::Mutex\*(C'\fR instance provides one basic operation, which will execute a
given block of code which returns a future, and itself returns a future to
represent that. The mutex can be in one of two states; either unlocked or
locked. While it is unlocked, requests to execute code are handled
immediately. Once a block of code is invoked, the mutex is now considered to
be locked, causing any subsequent requests to invoke code to be queued behind
the first one, until it completes. Once the initial code indicates completion
(by its returned future providing a result or failing), the next queued code
is invoked.
.PP
An instance may also be a counting mutex if initialised with a count greater
than one. In this case, it can keep multiple blocks outstanding up to that
limit, with subsequent requests queued as before. This allows it to act as a
concurrency-bounding limit around some operation that can run concurrently,
but an application wishes to apply overall limits to stop it growing too much,
such as communications with external services or executing other programs.
.SH CONSTRUCTOR
.IX Header "CONSTRUCTOR"
.SS new
.IX Subsection "new"
.Vb 1
\&   $mutex = Future::Mutex\->new( count => $n );
.Ve
.PP
Returns a new \f(CW\*(C`Future::Mutex\*(C'\fR instance. It is initially unlocked.
.PP
Takes the following named arguments:
.IP "count => INT" 8
.IX Item "count => INT"
Optional number to limit outstanding concurrency. Will default to 1 if not
supplied.
.SH METHODS
.IX Header "METHODS"
.SS enter
.IX Subsection "enter"
.Vb 1
\&   $f = $mutex\->enter( \e&code );
.Ve
.PP
Returns a new \f(CW\*(C`Future\*(C'\fR that represents the eventual result of calling the
code. If the mutex is currently unlocked, the code will be invoked
immediately. If it is currently locked, the code will be queued waiting for
the next time it becomes unlocked.
.PP
The code is invoked with no arguments, and is expected to return a \f(CW\*(C`Future\*(C'\fR.
The eventual result of that future determines the result of the future that
\&\f(CW\*(C`enter\*(C'\fR returned.
.SS available
.IX Subsection "available"
.Vb 1
\&   $avail = $mutex\->available;
.Ve
.PP
Returns true if the mutex is currently unlocked, or false if it is locked.
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
