.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Async::Timer::Countdown 3pm"
.TH IO::Async::Timer::Countdown 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"IO::Async::Timer::Countdown" \- event callback after a fixed delay
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&   use IO::Async::Timer::Countdown;
\&
\&   use IO::Async::Loop;
\&   my $loop = IO::Async::Loop\->new;
\&
\&   my $timer = IO::Async::Timer::Countdown\->new(
\&      delay => 10,
\&
\&      on_expire => sub {
\&         print "Sorry, your time\*(Aqs up\en";
\&         $loop\->stop;
\&      },
\&   );
\&
\&   $timer\->start;
\&
\&   $loop\->add( $timer );
\&
\&   $loop\->run;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This subclass of IO::Async::Timer implements one-shot fixed delays.
The object implements a countdown timer, which invokes its callback after the
given period from when it was started. After it has expired the Timer may be
started again, when it will wait the same period then invoke the callback
again. A timer that is currently running may be stopped or reset.
.PP
For a \f(CW\*(C`Timer\*(C'\fR object that repeatedly runs a callback at regular intervals,
see instead IO::Async::Timer::Periodic. For a \f(CW\*(C`Timer\*(C'\fR that invokes its
callback at a fixed time in the future, see IO::Async::Timer::Absolute.
.SH EVENTS
.IX Header "EVENTS"
The following events are invoked, either using subclass methods or CODE
references in parameters:
.SS on_expire
.IX Subsection "on_expire"
Invoked when the timer expires.
.SH PARAMETERS
.IX Header "PARAMETERS"
The following named parameters may be passed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`configure\*(C'\fR:
.SS "on_expire => CODE"
.IX Subsection "on_expire => CODE"
CODE reference for the \f(CW\*(C`on_expire\*(C'\fR event.
.SS "delay => NUM"
.IX Subsection "delay => NUM"
The delay in seconds after starting the timer until it expires. Cannot be
changed if the timer is running. A timer with a zero delay expires
"immediately".
.SS "remove_on_expire => BOOL"
.IX Subsection "remove_on_expire => BOOL"
Optional. If true, remove this timer object from its parent notifier or
containing loop when it expires. Defaults to false.
.PP
Once constructed, the timer object will need to be added to the \f(CW\*(C`Loop\*(C'\fR before
it will work. It will also need to be started by the \f(CW\*(C`start\*(C'\fR method.
.SH METHODS
.IX Header "METHODS"
.SS is_expired
.IX Subsection "is_expired"
.Vb 1
\&   $expired = $timer\->is_expired;
.Ve
.PP
Returns true if the Timer has already expired.
.SS reset
.IX Subsection "reset"
.Vb 1
\&   $timer\->reset;
.Ve
.PP
If the timer is running, restart the countdown period from now. If the timer
is not running, this method has no effect.
.SH EXAMPLES
.IX Header "EXAMPLES"
.SS "Watchdog Timer"
.IX Subsection "Watchdog Timer"
Because the \f(CW\*(C`reset\*(C'\fR method restarts a running countdown timer back to its
full period, it can be used to implement a watchdog timer. This is a timer
which will not expire provided the method is called at least as often as it
is configured. If the method fails to be called, the timer will eventually
expire and run its callback.
.PP
For example, to expire an accepted connection after 30 seconds of inactivity:
.PP
.Vb 1
\&   ...
\&
\&   on_accept => sub {
\&      my ( $newclient ) = @_;
\&
\&      my $watchdog = IO::Async::Timer::Countdown\->new(
\&         delay => 30,
\&
\&         on_expire => sub {
\&            my $self = shift;
\&
\&            my $stream = $self\->parent;
\&            $stream\->close;
\&         },
\&      );
\&
\&      my $stream = IO::Async::Stream\->new(
\&         handle => $newclient,
\&
\&         on_read => sub {
\&            my ( $self, $buffref, $eof ) = @_;
\&            $watchdog\->reset;
\&
\&            ...
\&         },
\&
\&         on_closed => sub {
\&            $watchdog\->stop;
\&         },
\&      ) );
\&
\&      $stream\->add_child( $watchdog );
\&      $watchdog\->start;
\&
\&      $loop\->add( $watchdog );
\&   }
.Ve
.PP
Rather than setting up a lexical variable to store the Stream so that the
Timer's \f(CW\*(C`on_expire\*(C'\fR closure can call \f(CW\*(C`close\*(C'\fR on it, the parent/child
relationship between the two Notifier objects is used. At the time the Timer
\&\f(CW\*(C`on_expire\*(C'\fR closure is invoked, it will have been added as a child notifier
of the Stream; this means the Timer's \f(CW\*(C`parent\*(C'\fR method will return the Stream
Notifier. This enables it to call \f(CW\*(C`close\*(C'\fR without needing to capture a
lexical variable, which would create a cyclic reference.
.SS "Fixed-Delay Repeating Timer"
.IX Subsection "Fixed-Delay Repeating Timer"
The \f(CW\*(C`on_expire\*(C'\fR event fires a fixed delay after the \f(CW\*(C`start\*(C'\fR method has begun
the countdown. The \f(CW\*(C`start\*(C'\fR method can be invoked again at some point during
the \f(CW\*(C`on_expire\*(C'\fR handling code, to create a timer that invokes its code
regularly a fixed delay after the previous invocation has finished. This
creates an arrangement similar to an IO::Async::Timer::Periodic, except
that it will wait until the previous invocation has indicated it is finished,
before starting the countdown for the next call.
.PP
.Vb 2
\&   my $timer = IO::Async::Timer::Countdown\->new(
\&      delay => 60,
\&
\&      on_expire => sub {
\&         my $self = shift;
\&
\&         start_some_operation(
\&            on_complete => sub { $self\->start },
\&         );
\&      },
\&   );
\&
\&   $timer\->start;
\&   $loop\->add( $timer );
.Ve
.PP
This example invokes the \f(CW\*(C`start_some_operation\*(C'\fR function 60 seconds after the
previous iteration has indicated it has finished.
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
