.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Async 3pm"
.TH IO::Async 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"IO::Async" \- Asynchronous event\-driven programming
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&   use IO::Async::Stream;
\&   use IO::Async::Loop;
\&
\&   my $loop = IO::Async::Loop\->new;
\&
\&   $loop\->connect(
\&      host     => "some.other.host",
\&      service  => 12345,
\&      socktype => \*(Aqstream\*(Aq,
\&
\&      on_stream => sub {
\&         my ( $stream ) = @_;
\&
\&         $stream\->configure(
\&            on_read => sub {
\&               my ( $self, $buffref, $eof ) = @_;
\&
\&               while( $$buffref =~ s/^(.*\en)// ) {
\&                  print "Received a line $1";
\&               }
\&
\&               return 0;
\&            }
\&         );
\&
\&         $stream\->write( "An initial line here\en" );
\&
\&         $loop\->add( $stream );
\&      },
\&
\&      on_resolve_error => sub { die "Cannot resolve \- $_[\-1]\en"; },
\&      on_connect_error => sub { die "Cannot connect \- $_[0] failed $_[\-1]\en"; },
\&   );
\&
\&   $loop\->run;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This collection of modules allows programs to be written that perform
asynchronous filehandle IO operations. A typical program using them would
consist of a single subclass of IO::Async::Loop to act as a container of
other objects, which perform the actual IO work required by the program. As
well as IO handles, the loop also supports timers and signal handlers, and
includes more higher-level functionality built on top of these basic parts.
.PP
Because there are a lot of classes in this collection, the following overview
gives a brief description of each.
.SS Notifiers
.IX Subsection "Notifiers"
The base class of all the event handling subclasses is IO::Async::Notifier.
It does not perform any IO operations itself, but instead acts as a base class
to build the specific IO functionality upon. It can also coordinate a
collection of other Notifiers contained within it, forming a tree structure.
.PP
The following sections describe particular types of Notifier.
.SS "File Handle IO"
.IX Subsection "File Handle IO"
An IO::Async::Handle object is a Notifier that represents a single IO handle
being managed. While in most cases it will represent a single filehandle, such
as a socket (for example, an IO::Socket::INET connection), it is possible
to have separate reading and writing handles (most likely for a program's
\&\f(CW\*(C`STDIN\*(C'\fR and \f(CW\*(C`STDOUT\*(C'\fR streams, or a pair of pipes connected to a child
process).
.PP
The IO::Async::Stream class is a subclass of IO::Async::Handle which
maintains internal incoming and outgoing data buffers. In this way, it
implements bidirectional buffering of a byte stream, such as a TCP socket. The
class automatically handles reading of incoming data into the incoming buffer,
and writing of the outgoing buffer. Methods or callbacks are used to inform
when new incoming data is available, or when the outgoing buffer is empty.
.PP
While stream-based sockets can be handled using using IO::Async::Stream,
datagram or raw sockets do not provide a bytestream. For these, the
IO::Async::Socket class is another subclass of IO::Async::Handle which
maintains an outgoing packet queue, and informs of packet receipt using a
callback or method.
.PP
The IO::Async::Listener class is another subclass of IO::Async::Handle
which facilitates the use of \f(CWlisten(2)\fR\-mode sockets. When a new connection
is available on the socket it will \f(CWaccept(2)\fR it and pass the new client
socket to its callback function.
.SS Timers
.IX Subsection "Timers"
An IO::Async::Timer::Absolute object represents a timer that expires at a
given absolute time in the future.
.PP
An IO::Async::Timer::Countdown object represents a count time timer, which
will invoke a callback after a given delay. It can be stopped and restarted.
.PP
An IO::Async::Timer::Periodic object invokes a callback at regular intervals
from its initial start time. It is reliable and will not drift due to the time
taken to run the callback.
.PP
The IO::Async::Loop also supports methods for managing timed events on a
lower level. Events may be absolute, or relative in time to the time they are
installed.
.SS Signals
.IX Subsection "Signals"
An IO::Async::Signal object represents a POSIX signal, which will invoke a
callback when the given signal is received by the process. Multiple objects
watching the same signal can be used; they will all invoke in no particular
order.
.SS "Processes Management"
.IX Subsection "Processes Management"
An IO::Async::PID object invokes its event when a given child process
exits. An IO::Async::Process object can start a new child process running
either a given block of code, or executing a given command, set up pipes on
its filehandles, write to or read from these pipes, and invoke its event when
the child process exits.
.SS Loops
.IX Subsection "Loops"
The IO::Async::Loop object class represents an abstract collection of
IO::Async::Notifier objects, and manages the actual filehandle IO
watchers, timers, signal handlers, and other functionality. It performs all
of the abstract collection management tasks, and leaves the actual OS
interactions to a particular subclass for the purpose.
.PP
IO::Async::Loop::Poll uses an IO::Poll object for this test.
.PP
IO::Async::Loop::Select uses the \f(CWselect(2)\fR syscall.
.PP
Other subclasses of loop may appear on CPAN under their own dists; see the
"SEE ALSO" section below for more detail.
.PP
As well as these general-purpose classes, the IO::Async::Loop constructor
also supports looking for OS-specific subclasses, in case a more efficient
implementation exists for the specific OS it runs on.
.SS "Child Processes"
.IX Subsection "Child Processes"
The IO::Async::Loop object provides a number of methods to facilitate the
running of child processes. \f(CW\*(C`spawn_child\*(C'\fR is primarily a wrapper around the
typical \f(CWfork(2)\fR/\f(CWexec(2)\fR style of starting child processes, and
\&\f(CW\*(C`run_child\*(C'\fR provide a method similar to perl's \f(CW\*(C`readpipe\*(C'\fR (which is used
to implement backticks \f(CW\`\`\fR).
.SS "File Change Watches"
.IX Subsection "File Change Watches"
The IO::Async::File object observes changes to \f(CWstat(2)\fR properties of a
file, directory, or other filesystem object. It invokes callbacks when
properties change. This is used by IO::Async::FileStream which presents
the same events as a IO::Async::Stream but operates on a regular file on
the filesystem, observing it for updates.
.SS "Asynchronous Co-routines and Functions"
.IX Subsection "Asynchronous Co-routines and Functions"
The \f(CW\*(C`IO::Async\*(C'\fR framework generally provides mechanisms for multiplexing IO
tasks between different handles, so there aren't many occasions when it is
necessary to run code in another thread or process. Two cases where this does
become useful are when:
.IP \(bu 4
A large amount of computationally-intensive work needs to be performed.
.IP \(bu 4
An OS or library-level function needs to be called, that will block, and
no asynchronous version is supplied.
.PP
For these cases, an instance of IO::Async::Function can be used around
a code block, to execute it in a worker child process or set of processes.
The code in the sub-process runs isolated from the main program, communicating
only by function call arguments and return values. This can be used to solve
problems involving state-less library functions.
.PP
An IO::Async::Routine object wraps a code block running in a separate
process to form a kind of co-routine. Communication with it happens via
IO::Async::Channel objects. It can be used to solve any sort of problem
involving keeping a possibly-stateful co-routine running alongside the rest of
an asynchronous program.
.SS Futures
.IX Subsection "Futures"
An IO::Async::Future object represents a single outstanding action that is
yet to complete, such as a name resolution operation or a socket connection.
It stands in contrast to a IO::Async::Notifier, which is an object that
represents an ongoing source of activity, such as a readable filehandle of
bytes or a POSIX signal.
.PP
Futures are a recent addition to the \f(CW\*(C`IO::Async\*(C'\fR API and details are still
subject to change and experimentation.
.PP
In general, methods that support Futures return a new Future object to
represent the outstanding operation. If callback functions are supplied as
well, these will be fired in addition to the Future object becoming ready. Any
failures that are reported will, in general, use the same conventions for the
Future's \f(CW\*(C`fail\*(C'\fR arguments to relate it to the legacy \f(CW\*(C`on_error\*(C'\fR\-style
callbacks.
.PP
.Vb 1
\&   $on_NAME_error\->( $message, @argmuents )
\&
\&   $f\->fail( $message, NAME, @arguments )
.Ve
.PP
where \f(CW$message\fR is a message intended for humans to read (so that this is
the message displayed by \f(CW\*(C`$f\->get\*(C'\fR if the failure is not otherwise
caught), \f(CW\*(C`NAME\*(C'\fR is the name of the failing operation. If the failure is due
to a failed system call, the value of \f(CW$!\fR will be the final argument. The
message should not end with a linefeed.
.SS Networking
.IX Subsection "Networking"
The IO::Async::Loop provides several methods for performing network-based
tasks. Primarily, the \f(CW\*(C`connect\*(C'\fR and \f(CW\*(C`listen\*(C'\fR methods allow the creation of
client or server network sockets. Additionally, the \f(CW\*(C`resolve\*(C'\fR method allows
the use of the system's name resolvers in an asynchronous way, to resolve
names into addresses, or vice versa. These methods are fully IPv6\-capable if
the underlying operating system is.
.SS Protocols
.IX Subsection "Protocols"
The IO::Async::Protocol class provides storage for a IO::Async::Handle
object, to act as a transport for some protocol. It allows a level of
independence from the actual transport being for that protocol, allowing it to
be easily reused. The IO::Async::Protocol::Stream subclass provides further
support for protocols based on stream connections, such as TCP sockets.
.SH TODO
.IX Header "TODO"
This collection of modules is still very much in development. As a result,
some of the potentially-useful parts or features currently missing are:
.IP \(bu 4
Consider further ideas on Solaris' \fIports\fR, BSD's \fIKevents\fR and anything that
might be useful on Win32.
.IP \(bu 4
Consider some form of persistent object wrapper in the form of an
\&\f(CW\*(C`IO::Async::Object\*(C'\fR, based on IO::Async::Routine.
.IP \(bu 4
\&\f(CW\*(C`IO::Async::Protocol::Datagram\*(C'\fR
.IP \(bu 4
Support for watching filesystem entries for change. Extract logic from
IO::Async::File and define a Loop watch/unwatch method pair.
.IP \(bu 4
Define more Future\-returning methods. Consider also one-shot Futures on
things like IO::Async::Process exits, or IO::Async::Handle close.
.SH SUPPORT
.IX Header "SUPPORT"
Bugs may be reported via RT at
.PP
.Vb 1
\&   https://rt.cpan.org/Public/Dist/Display.html?Name=IO\-Async
.Ve
.PP
Support by IRC may also be found on \fIirc.perl.org\fR in the \fI#io\-async\fR
channel.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
As well as the two loops supplied in this distribution, many more exist on
CPAN. At the time of writing this includes:
.IP \(bu 4
IO::Async::Loop::AnyEvent \- use IO::Async with AnyEvent
.IP \(bu 4
IO::Async::Loop::Epoll \- use IO::Async with epoll on Linux
.IP \(bu 4
IO::Async::Loop::Event \- use IO::Async with Event
.IP \(bu 4
IO::Async::Loop::EV \- use IO::Async with EV
.IP \(bu 4
IO::Async::Loop::Glib \- use IO::Async with Glib or GTK
.IP \(bu 4
IO::Async::Loop::KQueue \- use IO::Async with kqueue
.IP \(bu 4
IO::Async::Loop::Mojo \- use IO::Async with Mojolicious
.IP \(bu 4
IO::Async::Loop::POE \- use IO::Async with POE
.IP \(bu 4
IO::Async::Loop::Ppoll \- use IO::Async with \fBppoll\fR\|(2)
.PP
Additionally, some other event loops or modules also support being run on top
of \f(CW\*(C`IO::Async\*(C'\fR:
.IP \(bu 4
AnyEvent::Impl::IOAsync \- AnyEvent adapter for IO::Async
.IP \(bu 4
Gungho::Engine::IO::Async \- IO::Async Engine
.IP \(bu 4
POE::Loop::IO_Async \- IO::Async event loop support for POE
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
