.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Async::Handle 3pm"
.TH IO::Async::Handle 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"IO::Async::Handle" \- event callbacks for a non\-blocking file descriptor
.SH SYNOPSIS
.IX Header "SYNOPSIS"
This class is likely not to be used directly, because subclasses of it exist
to handle more specific cases. Here is an example of how it would be used to
watch a listening socket for new connections. In real code, it is likely that
the \f(CW\*(C`Loop\->listen\*(C'\fR method would be used instead.
.PP
.Vb 2
\&   use IO::Socket::INET;
\&   use IO::Async::Handle;
\&
\&   use IO::Async::Loop;
\&   my $loop = IO::Async::Loop\->new;
\&
\&   my $socket = IO::Socket::INET\->new( LocalPort => 1234, Listen => 1 );
\&
\&   my $handle = IO::Async::Handle\->new(
\&      handle => $socket,
\&
\&      on_read_ready  => sub {
\&         my $new_client = $socket\->accept; 
\&         ...
\&      },
\&   );
\&
\&   $loop\->add( $handle );
.Ve
.PP
For most other uses with sockets, pipes or other filehandles that carry a byte
stream, the IO::Async::Stream class is likely to be more suitable. For
non-stream sockets, see IO::Async::Socket.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This subclass of IO::Async::Notifier allows non-blocking IO on filehandles.
It provides event handlers for when the filehandle is read\- or write-ready.
.SH EVENTS
.IX Header "EVENTS"
The following events are invoked, either using subclass methods or CODE
references in parameters:
.SS on_read_ready
.IX Subsection "on_read_ready"
Invoked when the read handle becomes ready for reading.
.SS on_write_ready
.IX Subsection "on_write_ready"
Invoked when the write handle becomes ready for writing.
.SS on_closed
.IX Subsection "on_closed"
Optional. Invoked when the handle becomes closed.
.PP
This handler is invoked before the filehandles are closed and the Handle
removed from its containing Loop. The \f(CW\*(C`loop\*(C'\fR will still return the containing
Loop object.
.SH PARAMETERS
.IX Header "PARAMETERS"
The following named parameters may be passed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`configure\*(C'\fR:
.SS "read_handle => IO"
.IX Subsection "read_handle => IO"
.SS "write_handle => IO"
.IX Subsection "write_handle => IO"
The reading and writing IO handles. Each must implement the \f(CW\*(C`fileno\*(C'\fR method.
Primarily used for passing \f(CW\*(C`STDIN\*(C'\fR / \f(CW\*(C`STDOUT\*(C'\fR; see the SYNOPSIS section of
IO::Async::Stream for an example.
.SS "handle => IO"
.IX Subsection "handle => IO"
The IO handle for both reading and writing; instead of passing each separately
as above. Must implement \f(CW\*(C`fileno\*(C'\fR method in way that \f(CW\*(C`IO::Handle\*(C'\fR does.
.SS "read_fileno => INT"
.IX Subsection "read_fileno => INT"
.SS "write_fileno => INT"
.IX Subsection "write_fileno => INT"
File descriptor numbers for reading and writing. If these are given as an
alternative to \f(CW\*(C`read_handle\*(C'\fR or \f(CW\*(C`write_handle\*(C'\fR then a new \f(CW\*(C`IO::Handle\*(C'\fR
instance will be constructed around each.
.SS "on_read_ready => CODE"
.IX Subsection "on_read_ready => CODE"
.SS "on_write_ready => CODE"
.IX Subsection "on_write_ready => CODE"
.SS "on_closed => CODE"
.IX Subsection "on_closed => CODE"
CODE references for event handlers.
.SS "want_readready => BOOL"
.IX Subsection "want_readready => BOOL"
.SS "want_writeready => BOOL"
.IX Subsection "want_writeready => BOOL"
If present, enable or disable read\- or write-ready notification as per the
\&\f(CW\*(C`want_readready\*(C'\fR and \f(CW\*(C`want_writeready\*(C'\fR methods.
.PP
It is required that a matching \f(CW\*(C`on_read_ready\*(C'\fR or \f(CW\*(C`on_write_ready\*(C'\fR are
available for any handle that is provided; either passed as a callback CODE
reference or as an overridden the method. I.e. if only a \f(CW\*(C`read_handle\*(C'\fR is
given, then \f(CW\*(C`on_write_ready\*(C'\fR can be absent. If \f(CW\*(C`handle\*(C'\fR is used as a
shortcut, then both read and write-ready callbacks or methods are required.
.PP
If no IO handles are provided at construction time, the object is still
created but will not yet be fully-functional as a Handle. IO handles can be
assigned later using the \f(CW\*(C`set_handle\*(C'\fR or \f(CW\*(C`set_handles\*(C'\fR methods, or by
\&\f(CW\*(C`configure\*(C'\fR. This may be useful when constructing an object to represent a
network connection, before the \f(CWconnect(2)\fR has actually been performed yet.
.SH METHODS
.IX Header "METHODS"
The following methods documented in \f(CW\*(C`await\*(C'\fR expressions return Future
instances.
.SS set_handle
.IX Subsection "set_handle"
.Vb 1
\&   $handle\->set_handles( %params );
.Ve
.PP
Sets new reading or writing filehandles. Equivalent to calling the
\&\f(CW\*(C`configure\*(C'\fR method with the same parameters.
.SS set_handle
.IX Subsection "set_handle"
.Vb 1
\&   $handle\->set_handle( $fh );
.Ve
.PP
Shortcut for
.PP
.Vb 1
\&   $handle\->configure( handle => $fh );
.Ve
.SS close
.IX Subsection "close"
.Vb 1
\&   $handle\->close;
.Ve
.PP
This method calls \f(CW\*(C`close\*(C'\fR on the underlying IO handles. This method will then
remove the handle from its containing loop.
.SS close_read
.IX Subsection "close_read"
.SS close_write
.IX Subsection "close_write"
.Vb 1
\&   $handle\->close_read;
\&
\&   $handle\->close_write;
.Ve
.PP
Closes the underlying read or write handle, and deconfigures it from the
object. Neither of these methods will invoke the \f(CW\*(C`on_closed\*(C'\fR event, nor
remove the object from the Loop if there is still one open handle in the
object. Only when both handles are closed, will \f(CW\*(C`on_closed\*(C'\fR be fired, and the
object removed.
.SS new_close_future
.IX Subsection "new_close_future"
.Vb 1
\&   await $handle\->new_close_future;
.Ve
.PP
Returns a new IO::Async::Future object which will become done when the
handle is closed. Cancelling the \f(CW$future\fR will remove this notification
ability but will not otherwise affect the \f(CW$handle\fR.
.SS read_handle
.IX Subsection "read_handle"
.SS write_handle
.IX Subsection "write_handle"
.Vb 1
\&   $handle = $handle\->read_handle;
\&
\&   $handle = $handle\->write_handle;
.Ve
.PP
These accessors return the underlying IO handles.
.SS read_fileno
.IX Subsection "read_fileno"
.SS write_fileno
.IX Subsection "write_fileno"
.Vb 1
\&   $fileno = $handle\->read_fileno;
\&
\&   $fileno = $handle\->write_fileno;
.Ve
.PP
These accessors return the file descriptor numbers of the underlying IO
handles.
.SS want_readready
.IX Subsection "want_readready"
.SS want_writeready
.IX Subsection "want_writeready"
.Vb 1
\&   $value = $handle\->want_readready;
\&
\&   $oldvalue = $handle\->want_readready( $newvalue );
\&
\&   $value = $handle\->want_writeready;
\&
\&   $oldvalue = $handle\->want_writeready( $newvalue );
.Ve
.PP
These are the accessor for the \f(CW\*(C`want_readready\*(C'\fR and \f(CW\*(C`want_writeready\*(C'\fR
properties, which define whether the object is interested in knowing about 
read\- or write-readiness on the underlying file handle.
.SS socket
.IX Subsection "socket"
.Vb 1
\&   $handle\->socket( $ai );
.Ve
.PP
Convenient shortcut to creating a socket handle, as given by an addrinfo
structure, and setting it as the read and write handle for the object.
.PP
\&\f(CW$ai\fR may be either a \f(CW\*(C`HASH\*(C'\fR or \f(CW\*(C`ARRAY\*(C'\fR reference of the same form as given
to IO::Async::OS's \f(CW\*(C`extract_addrinfo\*(C'\fR method.
.PP
This method returns nothing if it succeeds, or throws an exception if it
fails.
.SS bind
.IX Subsection "bind"
.Vb 1
\&   $handle = await $handle\->bind( %args );
.Ve
.PP
Performs a \f(CW\*(C`getaddrinfo\*(C'\fR resolver operation with the \f(CW\*(C`passive\*(C'\fR flag set,
and then attempts to bind a socket handle of any of the return values.
.SS "bind (1 argument)"
.IX Subsection "bind (1 argument)"
.Vb 1
\&   $handle = await $handle\->bind( $ai );
.Ve
.PP
When invoked with a single argument, this method is a convenient shortcut to
creating a socket handle and \f(CWbind()\fRing it to the address as given by an
addrinfo structure, and setting it as the read and write handle for the
object.
.PP
\&\f(CW$ai\fR may be either a \f(CW\*(C`HASH\*(C'\fR or \f(CW\*(C`ARRAY\*(C'\fR reference of the same form as given
to IO::Async::OS's \f(CW\*(C`extract_addrinfo\*(C'\fR method.
.PP
The returned future returns the handle object itself for convenience.
.SS connect
.IX Subsection "connect"
.Vb 1
\&   $handle = await $handle\->connect( %args );
.Ve
.PP
A convenient wrapper for calling the \f(CW\*(C`connect\*(C'\fR method on the underlying
IO::Async::Loop object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP \(bu 4
IO::Handle \- Supply object methods for I/O handles
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
