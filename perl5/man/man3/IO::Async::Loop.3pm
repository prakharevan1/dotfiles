.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Async::Loop 3pm"
.TH IO::Async::Loop 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"IO::Async::Loop" \- core loop of the "IO::Async" framework
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&   use IO::Async::Stream;
\&   use IO::Async::Timer::Countdown;
\&
\&   use IO::Async::Loop;
\&
\&   my $loop = IO::Async::Loop\->new;
\&
\&   $loop\->add( IO::Async::Timer::Countdown\->new(
\&      delay => 10,
\&      on_expire => sub { print "10 seconds have passed\en" },
\&   )\->start );
\&
\&   $loop\->add( IO::Async::Stream\->new_for_stdin(
\&      on_read => sub {
\&         my ( $self, $buffref, $eof ) = @_;
\&
\&         while( $$buffref =~ s/^(.*)\en// ) {
\&            print "You typed a line $1\en";
\&         }
\&
\&         return 0;
\&      },
\&   ) );
\&
\&   $loop\->run;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module provides an abstract class which implements the core loop of the
IO::Async framework. Its primary purpose is to store a set of
IO::Async::Notifier objects or subclasses of them. It handles all of the
lower-level set manipulation actions, and leaves the actual IO readiness 
testing/notification to the concrete class that implements it. It also
provides other functionality such as signal handling, child process managing,
and timers.
.PP
See also the two bundled Loop subclasses:
.IP IO::Async::Loop::Select 4
.IX Item "IO::Async::Loop::Select"
.PD 0
.IP IO::Async::Loop::Poll 4
.IX Item "IO::Async::Loop::Poll"
.PD
.PP
Or other subclasses that may appear on CPAN which are not part of the core
IO::Async distribution.
.SS "Ignoring SIGPIPE"
.IX Subsection "Ignoring SIGPIPE"
Since version \fI0.66\fR loading this module automatically ignores \f(CW\*(C`SIGPIPE\*(C'\fR, as
it is highly unlikely that the default-terminate action is the best course of
action for an IO::Async\-based program to take. If at load time the handler
disposition is still set as \f(CW\*(C`DEFAULT\*(C'\fR, it is set to ignore. If already
another handler has been placed there by the program code, it will be left
undisturbed.
.SH "MAGIC CONSTRUCTOR"
.IX Header "MAGIC CONSTRUCTOR"
.SS new
.IX Subsection "new"
.Vb 1
\&   $loop = IO::Async::Loop\->new;
.Ve
.PP
This function attempts to find a good subclass to use, then calls its
constructor. It works by making a list of likely candidate classes, then
trying each one in turn, \f(CW\*(C`require\*(C'\fRing the module then calling its \f(CW\*(C`new\*(C'\fR
method. If either of these operations fails, the next subclass is tried. If
no class was successful, then an exception is thrown.
.PP
The constructed object is cached, and will be returned again by a subsequent
call. The cache will also be set by a constructor on a specific subclass. This
behaviour makes it possible to simply use the normal constructor in a module
that wishes to interact with the main program's Loop, such as an integration
module for another event system.
.PP
For example, the following two \f(CW$loop\fR variables will refer to the same
object:
.PP
.Vb 2
\&   use IO::Async::Loop;
\&   use IO::Async::Loop::Poll;
\&
\&   my $loop_poll = IO::Async::Loop::Poll\->new;
\&
\&   my $loop = IO::Async::Loop\->new;
.Ve
.PP
While it is not advised to do so under normal circumstances, if the program
really wishes to construct more than one Loop object, it can call the
constructor \f(CW\*(C`really_new\*(C'\fR, or invoke one of the subclass-specific constructors
directly.
.PP
The list of candidates is formed from the following choices, in this order:
.IP \(bu 4
\&\f(CW$ENV\fR{IO_ASYNC_LOOP}
.Sp
If this environment variable is set, it should contain a comma-separated list
of subclass names. These names may or may not be fully-qualified; if a name
does not contain \f(CW\*(C`::\*(C'\fR then it will have \f(CW\*(C`IO::Async::Loop::\*(C'\fR prepended to it.
This allows the end-user to specify a particular choice to fit the needs of
his use of a program using IO::Async.
.IP \(bu 4
\&\f(CW$IO::Async::Loop::LOOP\fR
.Sp
If this scalar is set, it should contain a comma-separated list of subclass
names. These may or may not be fully-qualified, as with the above case. This
allows a program author to suggest a loop module to use.
.Sp
In cases where the module subclass is a hard requirement, such as GTK programs
using \f(CW\*(C`Glib\*(C'\fR, it would be better to use the module specifically and invoke
its constructor directly.
.IP \(bu 4
IO::Async::OS\->LOOP_PREFER_CLASSES
.Sp
The IO::Async::OS hints module for the given OS is then consulted to see if
it suggests any other module classes specific to the given operating system.
.IP \(bu 4
$^O
.Sp
The module called \f(CW\*(C`IO::Async::Loop::$^O\*(C'\fR is tried next. This allows specific
OSes, such as the ever-tricky \f(CW\*(C`MSWin32\*(C'\fR, to provide an implementation that
might be more efficient than the generic ones, or even work at all.
.Sp
This option is now discouraged in favour of the IO::Async::OS hint instead.
At some future point it may be removed entirely, given as currently only
\&\f(CW\*(C`linux\*(C'\fR uses it.
.IP \(bu 4
Poll and Select
.Sp
Finally, if no other choice has been made by now, the built-in \f(CW\*(C`Poll\*(C'\fR module
is chosen. This should always work, but in case it doesn't, the \f(CW\*(C`Select\*(C'\fR
module will be chosen afterwards as a last-case attempt. If this also fails,
then the magic constructor itself will throw an exception.
.PP
If any of the explicitly-requested loop types (\f(CW$ENV{IO_ASYNC_LOOP}\fR or
\&\f(CW$IO::Async::Loop::LOOP\fR) fails to load then a warning is printed detailing
the error.
.PP
Implementors of new \f(CW\*(C`IO::Async::Loop\*(C'\fR subclasses should see the notes about
\&\f(CW\*(C`API_VERSION\*(C'\fR below.
.SH "NOTIFIER MANAGEMENT"
.IX Header "NOTIFIER MANAGEMENT"
The following methods manage the collection of IO::Async::Notifier objects.
.SS add
.IX Subsection "add"
.Vb 1
\&   $loop\->add( $notifier );
.Ve
.PP
This method adds another notifier object to the stored collection. The object
may be a IO::Async::Notifier, or any subclass of it.
.PP
When a notifier is added, any children it has are also added, recursively. In
this way, entire sections of a program may be written within a tree of
notifier objects, and added or removed on one piece.
.SS remove
.IX Subsection "remove"
.Vb 1
\&   $loop\->remove( $notifier );
.Ve
.PP
This method removes a notifier object from the stored collection, and
recursively and children notifiers it contains.
.SS notifiers
.IX Subsection "notifiers"
.Vb 1
\&   @notifiers = $loop\->notifiers;
.Ve
.PP
Returns a list of all the notifier objects currently stored in the Loop.
.SH "LOOPING CONTROL"
.IX Header "LOOPING CONTROL"
The following methods control the actual run cycle of the loop, and hence the
program.
.SS loop_once
.IX Subsection "loop_once"
.Vb 1
\&   $count = $loop\->loop_once( $timeout );
.Ve
.PP
This method performs a single wait loop using the specific subclass's
underlying mechanism. If \f(CW$timeout\fR is undef, then no timeout is applied, and
it will wait until an event occurs. The intention of the return value is to
indicate the number of callbacks that this loop executed, though different
subclasses vary in how accurately they can report this. See the documentation
for this method in the specific subclass for more information.
.SS run
.IX Subsection "run"
.Vb 1
\&   @result = $loop\->run;
\&
\&   $result = $loop\->run;
.Ve
.PP
Runs the actual IO event loop. This method blocks until the \f(CW\*(C`stop\*(C'\fR method is
called, and returns the result that was passed to \f(CW\*(C`stop\*(C'\fR. In scalar context
only the first result is returned; the others will be discarded if more than
one value was provided. This method may be called recursively.
.PP
This method is a recent addition and may not be supported by all the
\&\f(CW\*(C`IO::Async::Loop\*(C'\fR subclasses currently available on CPAN.
.SS stop
.IX Subsection "stop"
.Vb 1
\&   $loop\->stop( @result );
.Ve
.PP
Stops the inner-most \f(CW\*(C`run\*(C'\fR method currently in progress, causing it to return
the given \f(CW@result\fR.
.PP
This method is a recent addition and may not be supported by all the
\&\f(CW\*(C`IO::Async::Loop\*(C'\fR subclasses currently available on CPAN.
.SS loop_forever
.IX Subsection "loop_forever"
.Vb 1
\&   $loop\->loop_forever;
.Ve
.PP
A synonym for \f(CW\*(C`run\*(C'\fR, though this method does not return a result.
.SS loop_stop
.IX Subsection "loop_stop"
.Vb 1
\&   $loop\->loop_stop;
.Ve
.PP
A synonym for \f(CW\*(C`stop\*(C'\fR, though this method does not pass any results.
.SS post_fork
.IX Subsection "post_fork"
.Vb 1
\&   $loop\->post_fork;
.Ve
.PP
The base implementation of this method does nothing. It is provided in case
some Loop subclasses should take special measures after a \f(CWfork()\fR system
call if the main body of the program should survive in both running processes.
.PP
This may be required, for example, in a long-running server daemon that forks
multiple copies on startup after opening initial listening sockets. A loop
implementation that uses some in-kernel resource that becomes shared after
forking (for example, a Linux \f(CW\*(C`epoll\*(C'\fR or a BSD \f(CW\*(C`kqueue\*(C'\fR filehandle) would
need recreating in the new child process before the program can continue.
.SH "FUTURE SUPPORT"
.IX Header "FUTURE SUPPORT"
The following methods relate to IO::Async::Future objects.
.SS new_future
.IX Subsection "new_future"
.Vb 1
\&   $future = $loop\->new_future;
.Ve
.PP
Returns a new IO::Async::Future instance with a reference to the Loop.
.SS await
.IX Subsection "await"
.Vb 1
\&   await $loop\->await( $future );
.Ve
.PP
Blocks until the given future is ready, as indicated by its \f(CW\*(C`is_ready\*(C'\fR method.
As a convenience it returns the future, to simplify code:
.PP
.Vb 1
\&   my @result = await $loop\->await( $future );
.Ve
.SS await_all
.IX Subsection "await_all"
.Vb 1
\&   $loop\->await_all( @futures );
.Ve
.PP
Blocks until all the given futures are ready, as indicated by the \f(CW\*(C`is_ready\*(C'\fR
method. Equivalent to calling \f(CW\*(C`await\*(C'\fR on a \f(CW\*(C`Future\->wait_all\*(C'\fR except
that it doesn't create the surrounding future object.
.SS delay_future
.IX Subsection "delay_future"
.Vb 1
\&   await $loop\->delay_future( %args );
.Ve
.PP
Returns a new IO::Async::Future instance which will become done at a given
point in time. The \f(CW%args\fR should contain an \f(CW\*(C`at\*(C'\fR or \f(CW\*(C`after\*(C'\fR key as per the
\&\f(CW\*(C`watch_time\*(C'\fR method. The returned future may be cancelled to cancel the
timer. At the alloted time the future will succeed with an empty result list.
.SS timeout_future
.IX Subsection "timeout_future"
.Vb 1
\&   await $loop\->timeout_future( %args );
.Ve
.PP
Returns a new IO::Async::Future instance which will fail at a given point
in time. The \f(CW%args\fR should contain an \f(CW\*(C`at\*(C'\fR or \f(CW\*(C`after\*(C'\fR key as per the
\&\f(CW\*(C`watch_time\*(C'\fR method. The returned future may be cancelled to cancel the
timer. At the alloted time, the future will fail with the string \f(CW"Timeout"\fR.
.SH FEATURES
.IX Header "FEATURES"
Most of the following methods are higher-level wrappers around base
functionality provided by the low-level API documented below. They may be
used by IO::Async::Notifier subclasses or called directly by the program.
.PP
The following methods documented in \f(CW\*(C`await\*(C'\fR expressions return Future
instances.
.SS attach_signal
.IX Subsection "attach_signal"
.Vb 1
\&   $id = $loop\->attach_signal( $signal, $code );
.Ve
.PP
This method adds a new signal handler to watch the given signal. The same
signal can be attached to multiple times; its callback functions will all be
invoked, in no particular order.
.PP
The returned \f(CW$id\fR value can be used to identify the signal handler in case
it needs to be removed by the \f(CW\*(C`detach_signal\*(C'\fR method. Note that this value
may be an object reference, so if it is stored, it should be released after it
is cancelled, so the object itself can be freed.
.ie n .IP $signal 8
.el .IP \f(CW$signal\fR 8
.IX Item "$signal"
The name of the signal to attach to. This should be a bare name like \f(CW\*(C`TERM\*(C'\fR.
.ie n .IP $code 8
.el .IP \f(CW$code\fR 8
.IX Item "$code"
A CODE reference to the handling callback.
.PP
Attaching to \f(CW\*(C`SIGCHLD\*(C'\fR is not recommended because of the way all child
processes use it to report their termination. Instead, the \f(CW\*(C`watch_process\*(C'\fR
method should be used to watch for termination of a given child process. A
warning will be printed if \f(CW\*(C`SIGCHLD\*(C'\fR is passed here, but in future versions
of IO::Async this behaviour may be disallowed altogether.
.PP
See also POSIX for the \f(CW\*(C`SIG\fR\f(CIname\fR\f(CW\*(C'\fR constants.
.PP
For a more flexible way to use signals from within Notifiers, see instead the
IO::Async::Signal object.
.SS detach_signal
.IX Subsection "detach_signal"
.Vb 1
\&   $loop\->detach_signal( $signal, $id );
.Ve
.PP
Removes a previously-attached signal handler.
.ie n .IP $signal 8
.el .IP \f(CW$signal\fR 8
.IX Item "$signal"
The name of the signal to remove from. This should be a bare name like
\&\f(CW\*(C`TERM\*(C'\fR.
.ie n .IP $id 8
.el .IP \f(CW$id\fR 8
.IX Item "$id"
The value returned by the \f(CW\*(C`attach_signal\*(C'\fR method.
.SS later
.IX Subsection "later"
.Vb 1
\&   $loop\->later( $code );
\&
\&   $f = $loop\->later;
.Ve
.PP
Schedules a code reference to be invoked as soon as the current round of IO
operations is complete.
.PP
The code reference is never invoked immediately, though the loop will not
perform any blocking operations between when it is installed and when it is
invoked. It may call \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`poll\*(C'\fR or equivalent with a zero-second
timeout, and process any currently-pending IO conditions before the code is
invoked, but it will not block for a non-zero amount of time.
.PP
This method is implemented using the \f(CW\*(C`watch_idle\*(C'\fR method, with the \f(CW\*(C`when\*(C'\fR
parameter set to \f(CW\*(C`later\*(C'\fR. It will return an ID value that can be passed to
\&\f(CW\*(C`unwatch_idle\*(C'\fR if required.
.PP
\&\fISince version 0.78\fR: If no \f(CW$code\fR value is passed, a Future will be
returned instead. This allows for constructs such as:
.PP
.Vb 1
\&   await $loop\->later;
.Ve
.SS spawn_child
.IX Subsection "spawn_child"
.Vb 1
\&   $loop\->spawn_child( %params );
.Ve
.PP
This method creates a new child process to run a given code block or command.
The \f(CW%params\fR hash takes the following keys:
.IP "command => ARRAY or STRING" 8
.IX Item "command => ARRAY or STRING"
Either a reference to an array containing the command and its arguments, or a
plain string containing the command. This value is passed into perl's
\&\f(CW\*(C`exec\*(C'\fR function.
.IP "code => CODE" 8
.IX Item "code => CODE"
A block of code to execute in the child process. It will be called in scalar
context inside an \f(CW\*(C`eval\*(C'\fR block.
.IP "setup => ARRAY" 8
.IX Item "setup => ARRAY"
A reference to an array which gives file descriptors to set up in the child
process before running the code or command. See below.
.IP "on_exit => CODE" 8
.IX Item "on_exit => CODE"
A continuation to be called when the child processes exits. It will be invoked
in the following way:
.Sp
.Vb 1
\&   $on_exit\->( $pid, $exitcode, $dollarbang, $dollarat )
.Ve
.Sp
The second argument is passed the plain perl \f(CW$?\fR value.
.PP
Exactly one of the \f(CW\*(C`command\*(C'\fR or \f(CW\*(C`code\*(C'\fR keys must be specified.
.PP
If the \f(CW\*(C`command\*(C'\fR key is used, the given array or string is executed using the
\&\f(CW\*(C`exec\*(C'\fR function.
.PP
If the \f(CW\*(C`code\*(C'\fR key is used, the return value will be used as the \f(CWexit(2)\fR
code from the child if it returns (or 255 if it returned \f(CW\*(C`undef\*(C'\fR or thows an
exception).
.PP
.Vb 6
\& Case          | ($exitcode >> 8)       | $dollarbang | $dollarat
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-
\& exec succeeds | exit code from program |     0       |    ""
\& exec fails    |         255            |     $!      |    ""
\& $code returns |     return value       |     $!      |    ""
\& $code dies    |         255            |     $!      |    $@
.Ve
.PP
It is usually more convenient to use the \f(CW\*(C`open_process\*(C'\fR method in simple
cases where an external program is being started in order to interact with it
via file IO, or even \f(CW\*(C`run_child\*(C'\fR when only the final result is required,
rather than interaction while it is running.
.PP
\fR\f(CI\*(C`setup\*(C'\fR\fI array\fR
.IX Subsection "setup array"
.PP
This array gives a list of file descriptor operations to perform in the child
process after it has been \f(CWfork(2)\fRed from the parent, before running the code
or command. It consists of name/value pairs which are ordered; the operations
are performed in the order given.
.IP "fd\fIn\fR => ARRAY" 8
.IX Item "fdn => ARRAY"
Gives an operation on file descriptor \fIn\fR. The first element of the array
defines the operation to be performed:
.RS 8
.IP "[ 'close' ]" 4
.IX Item "[ 'close' ]"
The file descriptor will be closed.
.ie n .IP "[ 'dup', $io ]" 4
.el .IP "[ 'dup', \f(CW$io\fR ]" 4
.IX Item "[ 'dup', $io ]"
The file descriptor will be \f(CWdup2(2)\fRed from the given IO handle.
.ie n .IP "[ 'open', $mode, $file ]" 4
.el .IP "[ 'open', \f(CW$mode\fR, \f(CW$file\fR ]" 4
.IX Item "[ 'open', $mode, $file ]"
The file descriptor will be opened from the named file in the given mode. The
\&\f(CW$mode\fR string should be in the form usually given to the \f(CW\*(C`open\*(C'\fR function;
such as '<' or '>>'.
.IP "[ 'keep' ]" 4
.IX Item "[ 'keep' ]"
The file descriptor will not be closed; it will be left as-is.
.RE
.RS 8
.Sp
A non-reference value may be passed as a shortcut, where it would contain the
name of the operation with no arguments (i.e. for the \f(CW\*(C`close\*(C'\fR and \f(CW\*(C`keep\*(C'\fR
operations).
.RE
.IP "IO => ARRAY" 8
.IX Item "IO => ARRAY"
Shortcut for passing \f(CW\*(C`fd\fR\f(CIn\fR\f(CW\*(C'\fR, where \fIn\fR is the fileno of the IO
reference. In this case, the key must be a reference that implements the
\&\f(CW\*(C`fileno\*(C'\fR method. This is mostly useful for
.Sp
.Vb 1
\&   $handle => \*(Aqkeep\*(Aq
.Ve
.IP "fd\fIn\fR => IO" 8
.IX Item "fdn => IO"
A shortcut for the \f(CW\*(C`dup\*(C'\fR case given above.
.IP "stdin => ..." 8
.IX Item "stdin => ..."
.PD 0
.IP "stdout => ..." 8
.IX Item "stdout => ..."
.IP "stderr => ..." 8
.IX Item "stderr => ..."
.PD
Shortcuts for \f(CW\*(C`fd0\*(C'\fR, \f(CW\*(C`fd1\*(C'\fR and \f(CW\*(C`fd2\*(C'\fR respectively.
.IP "env => HASH" 8
.IX Item "env => HASH"
A reference to a hash to set as the child process's environment.
.Sp
Note that this will entirely set a new environment, completely replacing the
existing one. If you want to simply add new keys or change the values of some
keys without removing the other existing ones, you can simply copy \f(CW%ENV\fR
into the hash before setting new keys:
.Sp
.Vb 4
\&   env => {
\&      %ENV,
\&      ANOTHER => "key here",
\&   }
.Ve
.IP "nice => INT" 8
.IX Item "nice => INT"
Change the child process's scheduling priority using \f(CW\*(C`POSIX::nice\*(C'\fR.
.IP "chdir => STRING" 8
.IX Item "chdir => STRING"
Change the child process's working directory using \f(CW\*(C`chdir\*(C'\fR.
.IP "setuid => INT" 8
.IX Item "setuid => INT"
.PD 0
.IP "setgid => INT" 8
.IX Item "setgid => INT"
.PD
Change the child process's effective UID or GID.
.IP "setgroups => ARRAY" 8
.IX Item "setgroups => ARRAY"
Change the child process's groups list, to those groups whose numbers are
given in the ARRAY reference.
.Sp
On most systems, only the privileged superuser change user or group IDs.
IO::Async will \fBNOT\fR check before detaching the child process whether
this is the case.
.Sp
If setting both the primary GID and the supplementary groups list, it is
suggested to set the primary GID first. Moreover, some operating systems may
require that the supplementary groups list contains the primary GID.
.PP
If no directions for what to do with \f(CW\*(C`stdin\*(C'\fR, \f(CW\*(C`stdout\*(C'\fR and \f(CW\*(C`stderr\*(C'\fR are
given, a default of \f(CW\*(C`keep\*(C'\fR is implied. All other file descriptors will be
closed, unless a \f(CW\*(C`keep\*(C'\fR operation is given for them.
.PP
If \f(CW\*(C`setuid\*(C'\fR is used, be sure to place it after any other operations that
might require superuser privileges, such as \f(CW\*(C`setgid\*(C'\fR or opening special
files.
.PP

.PP
.Vb 3
\&   my ( $pipeRd, $pipeWr ) = IO::Async::OS\->pipepair;
\&   $loop\->spawn_child(
\&      command => "/usr/bin/my\-command",
\&
\&      setup => [
\&         stdin  => [ "open", "<", "/dev/null" ],
\&         stdout => $pipeWr,
\&         stderr => [ "open", ">>", "/var/log/mycmd.log" ],
\&         chdir  => "/",
\&      ]
\&
\&      on_exit => sub {
\&         my ( $pid, $exitcode ) = @_;
\&         my $status = ( $exitcode >> 8 );
\&         print "Command exited with status $status\en";
\&      },
\&   );
\&
\&   $loop\->spawn_child(
\&      code => sub {
\&         do_something; # executes in a child process
\&         return 1;
\&      },
\&
\&      on_exit => sub {
\&         my ( $pid, $exitcode, $dollarbang, $dollarat ) = @_;
\&         my $status = ( $exitcode >> 8 );
\&         print "Child process exited with status $status\en";
\&         print " OS error was $dollarbang, exception was $dollarat\en";
\&      },
\&   );
.Ve
.SS open_process
.IX Subsection "open_process"
.Vb 1
\&   $process = $loop\->open_process( %params );
.Ve
.PP
\&\fISince version 0.72.\fR
.PP
This creates a new child process to run the given code block or command, and
attaches filehandles to it that the parent will watch. This method is a light
wrapper around constructing a new IO::Async::Process object, adding it to
the loop, and returning it.
.PP
The \f(CW%params\fR hash is passed directly to the IO::Async::Process
constructor.
.SS open_child
.IX Subsection "open_child"
.Vb 1
\&   $pid = $loop\->open_child( %params );
.Ve
.PP
A back-compatibility wrapper to calling "open_process" and returning the PID
of the newly-constructed IO::Async::Process instance. The \f(CW\*(C`on_finish\*(C'\fR
continuation likewise will be invoked with the PID rather than the process
instance.
.PP
.Vb 1
\&   $on_finish\->( $pid, $exitcode );
.Ve
.PP
Similarly, a \f(CW\*(C`on_error\*(C'\fR continuation is accepted, though note its arguments
come in a different order to those of the Process's \f(CW\*(C`on_exception\*(C'\fR:
.PP
.Vb 1
\&   $on_error\->( $pid, $exitcode, $errno, $exception );
.Ve
.PP
This method should not be used in new code; instead use "open_process"
directly.
.SS run_process
.IX Subsection "run_process"
.Vb 1
\&   @results = await $loop\->run_process( %params );
\&
\&   ( $exitcode, $stdout ) = await $loop\->run_process( ... );  # by default
.Ve
.PP
\&\fISince version 0.73.\fR
.PP
Creates a new child process to run the given code block or command, optionally
capturing its STDOUT and STDERR streams. By default the returned future will
yield the exit code and content of the STDOUT stream, but the \f(CW\*(C`capture\*(C'\fR
argument can be used to alter what is requested and returned.
.IP "command => ARRAY or STRING" 8
.IX Item "command => ARRAY or STRING"
.PD 0
.IP "code => CODE" 8
.IX Item "code => CODE"
.PD
The command or code to run in the child process (as per the \f(CW\*(C`spawn_child\*(C'\fR
method)
.IP "stdin => STRING" 8
.IX Item "stdin => STRING"
Optional. String to pass in to the child process's STDIN stream.
.IP "setup => ARRAY" 8
.IX Item "setup => ARRAY"
Optional reference to an array to pass to the underlying \f(CW\*(C`spawn\*(C'\fR method.
.IP "capture => ARRAY" 8
.IX Item "capture => ARRAY"
Optional reference to an array giving a list of names of values which should
be returned by resolving future. Values will be returned in the same order as
in the list. Valid choices are: \f(CW\*(C`exitcode\*(C'\fR, \f(CW\*(C`stdout\*(C'\fR, \f(CW\*(C`stderr\*(C'\fR.
.IP "cancel_signal => STRING" 8
.IX Item "cancel_signal => STRING"
Optional. Name (or number) of the signal to send to the process if the
returned future is cancelled. Defaults to \f(CW\*(C`TERM\*(C'\fR. Use empty string or zero
disable sending a signal on cancellation.
.IP "fail_on_nonzero => BOOL" 8
.IX Item "fail_on_nonzero => BOOL"
Optional. If true, the returned future will fail if the process exits with a
nonzero status. The failure will contain a message, the \f(CW\*(C`process\*(C'\fR category
name, and the capture values that were requested.
.Sp
.Vb 1
\&   Future\->fail( $message, process => @captures );
.Ve
.PP
This method is intended mainly as an IO::Async\-compatible replacement for the
perl \f(CW\*(C`readpipe\*(C'\fR function (`backticks`), allowing it to replace
.PP
.Vb 1
\&   my $output = \`command here\`;
.Ve
.PP
with
.PP
.Vb 3
\&   my ( $exitcode, $output ) = await $loop\->run_process(
\&      command => "command here", 
\&   );
.Ve
.PP

.PP
.Vb 3
\&   my ( $exitcode, $stdout ) = await $loop\->run_process(
\&      command => "/bin/ps",
\&   );
\&
\&   my $status = ( $exitcode >> 8 );
\&   print "ps exited with status $status\en";
.Ve
.SS run_child
.IX Subsection "run_child"
.Vb 1
\&   $pid = $loop\->run_child( %params );
.Ve
.PP
A back-compatibility wrapper for "run_process", returning the PID and taking
an \f(CW\*(C`on_finish\*(C'\fR continuation instead of returning a Future.
.PP
This creates a new child process to run the given code block or command,
capturing its STDOUT and STDERR streams. When the process exits, a
continuation is invoked being passed the exitcode, and content of the streams.
.PP
Takes the following named arguments in addition to those taken by
\&\f(CW\*(C`run_process\*(C'\fR:
.IP "on_finish => CODE" 8
.IX Item "on_finish => CODE"
A continuation to be called when the child process exits and closed its STDOUT
and STDERR streams. It will be invoked in the following way:
.Sp
.Vb 1
\&   $on_finish\->( $pid, $exitcode, $stdout, $stderr );
.Ve
.Sp
The second argument is passed the plain perl \f(CW$?\fR value.
.PP
This method should not be used in new code; instead use "run_process"
directly.
.SS resolver
.IX Subsection "resolver"
.Vb 1
\&   $resolver = $loop\->resolver;
.Ve
.PP
Returns the internally-stored IO::Async::Resolver object, used for name
resolution operations by the \f(CW\*(C`resolve\*(C'\fR, \f(CW\*(C`connect\*(C'\fR and \f(CW\*(C`listen\*(C'\fR methods.
.SS set_resolver
.IX Subsection "set_resolver"
.Vb 1
\&   $loop\->set_resolver( $resolver );
.Ve
.PP
Sets the internally-stored IO::Async::Resolver object. In most cases this
method should not be required, but it may be used to provide an alternative
resolver for special use-cases.
.SS resolve
.IX Subsection "resolve"
.Vb 1
\&   @result = await $loop\->resolve( %params );
.Ve
.PP
This method performs a single name resolution operation. It uses an
internally-stored IO::Async::Resolver object. For more detail, see the
\&\f(CW\*(C`resolve\*(C'\fR method on the IO::Async::Resolver class.
.SS connect
.IX Subsection "connect"
.Vb 1
\&   $handle|$socket = await $loop\->connect( %params );
.Ve
.PP
This method performs a non-blocking connection to a given address or set of
addresses, returning a IO::Async::Future which represents the operation. On
completion, the future will yield the connected socket handle, or the given
IO::Async::Handle object.
.PP
There are two modes of operation. Firstly, a list of addresses can be provided
which will be tried in turn. Alternatively as a convenience, if a host and
service name are provided instead of a list of addresses, these will be
resolved using the underlying loop's \f(CW\*(C`resolve\*(C'\fR method into the list of
addresses.
.PP
When attempting to connect to any among a list of addresses, there may be
failures among the first attempts, before a valid connection is made. For
example, the resolver may have returned some IPv6 addresses, but only IPv4
routes are valid on the system. In this case, the first \f(CWconnect(2)\fR syscall
will fail. This isn't yet a fatal error, if there are more addresses to try,
perhaps some IPv4 ones.
.PP
For this reason, it is possible that the operation eventually succeeds even
though some system calls initially fail. To be aware of individual failures,
the optional \f(CW\*(C`on_fail\*(C'\fR callback can be used. This will be invoked on each
individual \f(CWsocket(2)\fR or \f(CWconnect(2)\fR failure, which may be useful for
debugging or logging.
.PP
Because this module simply uses the \f(CW\*(C`getaddrinfo\*(C'\fR resolver, it will be fully
IPv6\-aware if the underlying platform's resolver is. This allows programs to
be fully IPv6\-capable.
.PP
In plain address mode, the \f(CW%params\fR hash takes the following keys:
.IP "addrs => ARRAY" 8
.IX Item "addrs => ARRAY"
Reference to an array of (possibly-multiple) address structures to attempt to
connect to. Each should be in the layout described for \f(CW\*(C`addr\*(C'\fR. Such a layout
is returned by the \f(CW\*(C`getaddrinfo\*(C'\fR named resolver.
.IP "addr => HASH or ARRAY" 8
.IX Item "addr => HASH or ARRAY"
Shortcut for passing a single address to connect to; it may be passed directly
with this key, instead of in another array on its own. This should be in a
format recognised by IO::Async::OS's \f(CW\*(C`extract_addrinfo\*(C'\fR method.
.Sp
This example shows how to use the \f(CW\*(C`Socket\*(C'\fR functions to construct one for TCP
port 8001 on address 10.0.0.1:
.Sp
.Vb 9
\&   $loop\->connect(
\&      addr => {
\&         family   => "inet",
\&         socktype => "stream",
\&         port     => 8001,
\&         ip       => "10.0.0.1",
\&      },
\&      ...
\&   );
.Ve
.Sp
This example shows another way to connect to a UNIX socket at \fIecho.sock\fR.
.Sp
.Vb 8
\&   $loop\->connect(
\&      addr => {
\&         family   => "unix",
\&         socktype => "stream",
\&         path     => "echo.sock",
\&      },
\&      ...
\&   );
.Ve
.IP "peer => IO" 8
.IX Item "peer => IO"
Shortcut for constructing an address to connect to the given IO handle, which
must be a IO::Socket or subclass, and is presumed to be a local listening
socket (perhaps on \f(CW\*(C`PF_UNIX\*(C'\fR or \f(CW\*(C`PF_INET\*(C'\fR). This is convenient for
connecting to a local filehandle, for example during a unit test or similar.
.IP "local_addrs => ARRAY" 8
.IX Item "local_addrs => ARRAY"
.PD 0
.IP "local_addr => HASH or ARRAY" 8
.IX Item "local_addr => HASH or ARRAY"
.PD
Optional. Similar to the \f(CW\*(C`addrs\*(C'\fR or \f(CW\*(C`addr\*(C'\fR parameters, these specify a local
address or set of addresses to \f(CWbind(2)\fR the socket to before
\&\f(CWconnect(2)\fRing it.
.PP
When performing the resolution step too, the \f(CW\*(C`addrs\*(C'\fR or \f(CW\*(C`addr\*(C'\fR keys are
ignored, and instead the following keys are taken:
.IP "host => STRING" 8
.IX Item "host => STRING"
.PD 0
.IP "service => STRING" 8
.IX Item "service => STRING"
.PD
The hostname and service name to connect to.
.IP "local_host => STRING" 8
.IX Item "local_host => STRING"
.PD 0
.IP "local_service => STRING" 8
.IX Item "local_service => STRING"
.PD
Optional. The hostname and/or service name to \f(CWbind(2)\fR the socket to locally
before connecting to the peer.
.IP "family => INT" 8
.IX Item "family => INT"
.PD 0
.IP "socktype => INT" 8
.IX Item "socktype => INT"
.IP "protocol => INT" 8
.IX Item "protocol => INT"
.IP "flags => INT" 8
.IX Item "flags => INT"
.PD
Optional. Other arguments to pass along with \f(CW\*(C`host\*(C'\fR and \f(CW\*(C`service\*(C'\fR to the
\&\f(CW\*(C`getaddrinfo\*(C'\fR call.
.IP "socktype => STRING" 8
.IX Item "socktype => STRING"
Optionally may instead be one of the values \f(CW\*(Aqstream\*(Aq\fR, \f(CW\*(Aqdgram\*(Aq\fR or
\&\f(CW\*(Aqraw\*(Aq\fR to stand for \f(CW\*(C`SOCK_STREAM\*(C'\fR, \f(CW\*(C`SOCK_DGRAM\*(C'\fR or \f(CW\*(C`SOCK_RAW\*(C'\fR. This
utility is provided to allow the caller to avoid a separate \f(CW\*(C`use Socket\*(C'\fR only
for importing these constants.
.PP
It is necessary to pass the \f(CW\*(C`socktype\*(C'\fR hint to the resolver when resolving
the host/service names into an address, as some OS's \f(CW\*(C`getaddrinfo\*(C'\fR functions
require this hint. A warning is emitted if neither \f(CW\*(C`socktype\*(C'\fR nor \f(CW\*(C`protocol\*(C'\fR
hint is defined when performing a \f(CW\*(C`getaddrinfo\*(C'\fR lookup. To avoid this warning
while still specifying no particular \f(CW\*(C`socktype\*(C'\fR hint (perhaps to invoke some
OS-specific behaviour), pass \f(CW0\fR as the \f(CW\*(C`socktype\*(C'\fR value.
.PP
In either case, it also accepts the following arguments:
.IP "handle => IO::Async::Handle" 8
.IX Item "handle => IO::Async::Handle"
Optional. If given a IO::Async::Handle object or a subclass (such as
IO::Async::Stream or IO::Async::Socket its handle will be set to the
newly-connected socket on success, and that handle used as the result of the
future instead.
.IP "on_fail => CODE" 8
.IX Item "on_fail => CODE"
Optional. After an individual \f(CWsocket(2)\fR or \f(CWconnect(2)\fR syscall has failed,
this callback is invoked to inform of the error. It is passed the name of the
syscall that failed, the arguments that were passed to it, and the error it
generated. I.e.
.Sp
.Vb 1
\&   $on_fail\->( "socket", $family, $socktype, $protocol, $! );
\&
\&   $on_fail\->( "bind", $sock, $address, $! );
\&
\&   $on_fail\->( "connect", $sock, $address, $! );
.Ve
.Sp
Because of the "try all" nature when given a list of multiple addresses, this
callback may be invoked multiple times, even before an eventual success.
.PP
This method accepts an \f(CW\*(C`extensions\*(C'\fR parameter; see the \f(CW\*(C`EXTENSIONS\*(C'\fR section
below.
.SS "connect (void)"
.IX Subsection "connect (void)"
.Vb 1
\&   $loop\->connect( %params );
.Ve
.PP
When not returning a future, additional parameters can be given containing the
continuations to invoke on success or failure.
.IP "on_connected => CODE" 8
.IX Item "on_connected => CODE"
A continuation that is invoked on a successful \f(CWconnect(2)\fR call to a valid
socket. It will be passed the connected socket handle, as an \f(CW\*(C`IO::Socket\*(C'\fR
object.
.Sp
.Vb 1
\&   $on_connected\->( $handle );
.Ve
.IP "on_stream => CODE" 8
.IX Item "on_stream => CODE"
An alternative to \f(CW\*(C`on_connected\*(C'\fR, a continuation that is passed an instance
of IO::Async::Stream when the socket is connected. This is provided as a
convenience for the common case that a Stream object is required as the
transport for a Protocol object.
.Sp
.Vb 1
\&   $on_stream\->( $stream )
.Ve
.IP "on_socket => CODE" 8
.IX Item "on_socket => CODE"
Similar to \f(CW\*(C`on_stream\*(C'\fR, but constructs an instance of IO::Async::Socket.
This is most useful for \f(CW\*(C`SOCK_DGRAM\*(C'\fR or \f(CW\*(C`SOCK_RAW\*(C'\fR sockets.
.Sp
.Vb 1
\&   $on_socket\->( $socket );
.Ve
.IP "on_connect_error => CODE" 8
.IX Item "on_connect_error => CODE"
A continuation that is invoked after all of the addresses have been tried, and
none of them succeeded. It will be passed the most significant error that
occurred, and the name of the operation it occurred in. Errors from the
\&\f(CWconnect(2)\fR syscall are considered most significant, then \f(CWbind(2)\fR, then
finally \f(CWsocket(2)\fR.
.Sp
.Vb 1
\&   $on_connect_error\->( $syscall, $! );
.Ve
.IP "on_resolve_error => CODE" 8
.IX Item "on_resolve_error => CODE"
A continuation that is invoked when the name resolution attempt fails. This is
invoked in the same way as the \f(CW\*(C`on_error\*(C'\fR continuation for the \f(CW\*(C`resolve\*(C'\fR
method.
.SS listen
.IX Subsection "listen"
.Vb 1
\&   $listener = await $loop\->listen( %params );
.Ve
.PP
This method sets up a listening socket and arranges for an acceptor callback
to be invoked each time a new connection is accepted on the socket. Internally
it creates an instance of IO::Async::Listener and adds it to the Loop if
not given one in the arguments.
.PP
Addresses may be given directly, or they may be looked up using the system's
name resolver, or a socket handle may be given directly.
.PP
If multiple addresses are given, or resolved from the service and hostname,
then each will be attempted in turn until one succeeds.
.PP
In named resolver mode, the \f(CW%params\fR hash takes the following keys:
.IP "service => STRING" 8
.IX Item "service => STRING"
The service name to listen on.
.IP "host => STRING" 8
.IX Item "host => STRING"
The hostname to listen on. Optional. Will listen on all addresses if not
supplied.
.IP "family => INT" 8
.IX Item "family => INT"
.PD 0
.IP "socktype => INT" 8
.IX Item "socktype => INT"
.IP "protocol => INT" 8
.IX Item "protocol => INT"
.IP "flags => INT" 8
.IX Item "flags => INT"
.PD
Optional. Other arguments to pass along with \f(CW\*(C`host\*(C'\fR and \f(CW\*(C`service\*(C'\fR to the
\&\f(CW\*(C`getaddrinfo\*(C'\fR call.
.IP "socktype => STRING" 8
.IX Item "socktype => STRING"
Optionally may instead be one of the values \f(CW\*(Aqstream\*(Aq\fR, \f(CW\*(Aqdgram\*(Aq\fR or
\&\f(CW\*(Aqraw\*(Aq\fR to stand for \f(CW\*(C`SOCK_STREAM\*(C'\fR, \f(CW\*(C`SOCK_DGRAM\*(C'\fR or \f(CW\*(C`SOCK_RAW\*(C'\fR. This
utility is provided to allow the caller to avoid a separate \f(CW\*(C`use Socket\*(C'\fR only
for importing these constants.
.PP
It is necessary to pass the \f(CW\*(C`socktype\*(C'\fR hint to the resolver when resolving
the host/service names into an address, as some OS's \f(CW\*(C`getaddrinfo\*(C'\fR functions
require this hint. A warning is emitted if neither \f(CW\*(C`socktype\*(C'\fR nor \f(CW\*(C`protocol\*(C'\fR
hint is defined when performing a \f(CW\*(C`getaddrinfo\*(C'\fR lookup. To avoid this warning
while still specifying no particular \f(CW\*(C`socktype\*(C'\fR hint (perhaps to invoke some
OS-specific behaviour), pass \f(CW0\fR as the \f(CW\*(C`socktype\*(C'\fR value.
.PP
In plain address mode, the \f(CW%params\fR hash takes the following keys:
.IP "addrs => ARRAY" 8
.IX Item "addrs => ARRAY"
Reference to an array of (possibly-multiple) address structures to attempt to
listen on. Each should be in the layout described for \f(CW\*(C`addr\*(C'\fR. Such a layout
is returned by the \f(CW\*(C`getaddrinfo\*(C'\fR named resolver.
.IP "addr => ARRAY" 8
.IX Item "addr => ARRAY"
Shortcut for passing a single address to listen on; it may be passed directly
with this key, instead of in another array of its own. This should be in a
format recognised by IO::Async::OS's \f(CW\*(C`extract_addrinfo\*(C'\fR method. See also
the \f(CW\*(C`EXAMPLES\*(C'\fR section.
.PP
In direct socket handle mode, the following keys are taken:
.IP "handle => IO" 8
.IX Item "handle => IO"
The listening socket handle.
.PP
In either case, the following keys are also taken:
.IP "on_fail => CODE" 8
.IX Item "on_fail => CODE"
Optional. A callback that is invoked if a syscall fails while attempting to
create a listening sockets. It is passed the name of the syscall that failed,
the arguments that were passed to it, and the error generated. I.e.
.Sp
.Vb 1
\&   $on_fail\->( "socket", $family, $socktype, $protocol, $! );
\&
\&   $on_fail\->( "sockopt", $sock, $optname, $optval, $! );
\&
\&   $on_fail\->( "bind", $sock, $address, $! );
\&
\&   $on_fail\->( "listen", $sock, $queuesize, $! );
.Ve
.IP "queuesize => INT" 8
.IX Item "queuesize => INT"
Optional. The queue size to pass to the \f(CWlisten(2)\fR calls. If not supplied,
then 3 will be given instead.
.IP "reuseaddr => BOOL" 8
.IX Item "reuseaddr => BOOL"
Optional. If true or not supplied then the \f(CW\*(C`SO_REUSEADDR\*(C'\fR socket option will
be set. To prevent this, pass a false value such as 0.
.IP "v6only => BOOL" 8
.IX Item "v6only => BOOL"
Optional. If defined, sets or clears the \f(CW\*(C`IPV6_V6ONLY\*(C'\fR socket option on
\&\f(CW\*(C`PF_INET6\*(C'\fR sockets. This option disables the ability of \f(CW\*(C`PF_INET6\*(C'\fR socket to
accept connections from \f(CW\*(C`AF_INET\*(C'\fR addresses. Not all operating systems allow
this option to be disabled.
.PP
An alternative which gives more control over the listener, is to create the
IO::Async::Listener object directly and add it explicitly to the Loop.
.PP
This method accepts an \f(CW\*(C`extensions\*(C'\fR parameter; see the \f(CW\*(C`EXTENSIONS\*(C'\fR section
below.
.SS "listen (void)"
.IX Subsection "listen (void)"
.Vb 1
\&   $loop\->listen( %params );
.Ve
.PP
When not returning a future, additional parameters can be given containing the
continuations to invoke on success or failure.
.IP "on_notifier => CODE" 8
.IX Item "on_notifier => CODE"
Optional. A callback that is invoked when the Listener object is ready to
receive connections. The callback is passed the Listener object itself.
.Sp
.Vb 1
\&   $on_notifier\->( $listener );
.Ve
.Sp
If this callback is required, it may instead be better to construct the
Listener object directly.
.IP "on_listen => CODE" 8
.IX Item "on_listen => CODE"
Optional. A callback that is invoked when the listening socket is ready.
Typically this would be used in the name resolver case, in order to inspect
the socket's sockname address, or otherwise inspect the filehandle.
.Sp
.Vb 1
\&   $on_listen\->( $socket )
.Ve
.IP "on_listen_error => CODE" 8
.IX Item "on_listen_error => CODE"
A continuation this is invoked after all of the addresses have been tried, and
none of them succeeded. It will be passed the most significant error that
occurred, and the name of the operation it occurred in. Errors from the
\&\f(CWlisten(2)\fR syscall are considered most significant, then \f(CWbind(2)\fR, then
\&\f(CWsockopt(2)\fR, then finally \f(CWsocket(2)\fR.
.IP "on_resolve_error => CODE" 8
.IX Item "on_resolve_error => CODE"
A continuation that is invoked when the name resolution attempt fails. This is
invoked in the same way as the \f(CW\*(C`on_error\*(C'\fR continuation for the \f(CW\*(C`resolve\*(C'\fR
method.
.SH "OS ABSTRACTIONS"
.IX Header "OS ABSTRACTIONS"
Because the Magic Constructor searches for OS-specific subclasses of the Loop,
several abstractions of OS services are provided, in case specific OSes need
to give different implementations on that OS.
.SS signame2num
.IX Subsection "signame2num"
.Vb 1
\&   $signum = $loop\->signame2num( $signame );
.Ve
.PP
Legacy wrappers around IO::Async::OS functions.
.SS time
.IX Subsection "time"
.Vb 1
\&   $time = $loop\->time;
.Ve
.PP
Returns the current UNIX time in fractional seconds. This is currently
equivalent to \f(CW\*(C`Time::HiRes::time\*(C'\fR but provided here as a utility for
programs to obtain the time current used by IO::Async for its own timing
purposes.
.SS fork
.IX Subsection "fork"
.Vb 1
\&   $pid = $loop\->fork( %params );
.Ve
.PP
This method creates a new child process to run a given code block, returning
its process ID.
.IP "code => CODE" 8
.IX Item "code => CODE"
A block of code to execute in the child process. It will be called in scalar
context inside an \f(CW\*(C`eval\*(C'\fR block. The return value will be used as the
\&\f(CWexit(2)\fR code from the child if it returns (or 255 if it returned \f(CW\*(C`undef\*(C'\fR or
thows an exception).
.IP "on_exit => CODE" 8
.IX Item "on_exit => CODE"
A optional continuation to be called when the child processes exits. It will
be invoked in the following way:
.Sp
.Vb 1
\&   $on_exit\->( $pid, $exitcode );
.Ve
.Sp
The second argument is passed the plain perl \f(CW$?\fR value.
.Sp
This key is optional; if not supplied, the calling code should install a
handler using the \f(CW\*(C`watch_process\*(C'\fR method.
.IP "keep_signals => BOOL" 8
.IX Item "keep_signals => BOOL"
Optional boolean. If missing or false, any CODE references in the \f(CW%SIG\fR hash
will be removed and restored back to \f(CW\*(C`DEFAULT\*(C'\fR in the child process. If true,
no adjustment of the \f(CW%SIG\fR hash will be performed.
.SS create_thread
.IX Subsection "create_thread"
.Vb 1
\&   $tid = $loop\->create_thread( %params );
.Ve
.PP
This method creates a new (non-detached) thread to run the given code block,
returning its thread ID.
.IP "code => CODE" 8
.IX Item "code => CODE"
A block of code to execute in the thread. It is called in the context given by
the \f(CW\*(C`context\*(C'\fR argument, and its return value will be available to the
\&\f(CW\*(C`on_joined\*(C'\fR callback. It is called inside an \f(CW\*(C`eval\*(C'\fR block; if it fails the
exception will be caught.
.IP "context => ""scalar"" | ""list"" | ""void""" 8
.IX Item "context => ""scalar"" | ""list"" | ""void"""
Optional. Gives the calling context that \f(CW\*(C`code\*(C'\fR is invoked in. Defaults to
\&\f(CW\*(C`scalar\*(C'\fR if not supplied.
.IP "on_joined => CODE" 8
.IX Item "on_joined => CODE"
Callback to invoke when the thread function returns or throws an exception.
If it returned, this callback will be invoked with its result
.Sp
.Vb 1
\&   $on_joined\->( return => @result );
.Ve
.Sp
If it threw an exception the callback is invoked with the value of \f(CW$@\fR
.Sp
.Vb 1
\&   $on_joined\->( died => $! );
.Ve
.SH "LOW-LEVEL METHODS"
.IX Header "LOW-LEVEL METHODS"
As \f(CW\*(C`IO::Async::Loop\*(C'\fR is an abstract base class, specific subclasses of it are
required to implement certain methods that form the base level of
functionality. They are not recommended for applications to use; see instead
the various event objects or higher level methods listed above.
.PP
These methods should be considered as part of the interface contract required
to implement a \f(CW\*(C`IO::Async::Loop\*(C'\fR subclass.
.SS API_VERSION
.IX Subsection "API_VERSION"
.Vb 1
\&   IO::Async::Loop\->API_VERSION;
.Ve
.PP
This method will be called by the magic constructor on the class before it is
constructed, to ensure that the specific implementation will support the
required API. This method should return the API version that the loop
implementation supports. The magic constructor will use that class, provided
it declares a version at least as new as the version documented here.
.PP
The current API version is \f(CW0.49\fR.
.PP
This method may be implemented using \f(CW\*(C`constant\*(C'\fR; e.g
.PP
.Vb 1
\&   use constant API_VERSION => \*(Aq0.49\*(Aq;
.Ve
.SS watch_io
.IX Subsection "watch_io"
.Vb 1
\&   $loop\->watch_io( %params );
.Ve
.PP
This method installs callback functions which will be invoked when the given
IO handle becomes read\- or write-ready.
.PP
The \f(CW%params\fR hash takes the following keys:
.IP "handle => IO" 8
.IX Item "handle => IO"
The IO handle to watch.
.IP "on_read_ready => CODE" 8
.IX Item "on_read_ready => CODE"
Optional. A CODE reference to call when the handle becomes read-ready.
.IP "on_write_ready => CODE" 8
.IX Item "on_write_ready => CODE"
Optional. A CODE reference to call when the handle becomes write-ready.
.PP
There can only be one filehandle of any given fileno registered at any one
time. For any one filehandle, there can only be one read-readiness and/or one
write-readiness callback at any one time. Registering a new one will remove an
existing one of that type. It is not required that both are provided.
.PP
Applications should use a IO::Async::Handle or IO::Async::Stream instead
of using this method.
.PP
If the filehandle does not yet have the \f(CW\*(C`O_NONBLOCK\*(C'\fR flag set, it will be
enabled by this method. This will ensure that any subsequent \f(CW\*(C`sysread\*(C'\fR,
\&\f(CW\*(C`syswrite\*(C'\fR, or similar will not block on the filehandle.
.SS unwatch_io
.IX Subsection "unwatch_io"
.Vb 1
\&   $loop\->unwatch_io( %params );
.Ve
.PP
This method removes a watch on an IO handle which was previously installed by
\&\f(CW\*(C`watch_io\*(C'\fR.
.PP
The \f(CW%params\fR hash takes the following keys:
.IP "handle => IO" 8
.IX Item "handle => IO"
The IO handle to remove the watch for.
.IP "on_read_ready => BOOL" 8
.IX Item "on_read_ready => BOOL"
If true, remove the watch for read-readiness.
.IP "on_write_ready => BOOL" 8
.IX Item "on_write_ready => BOOL"
If true, remove the watch for write-readiness.
.PP
Either or both callbacks may be removed at once. It is not an error to attempt
to remove a callback that is not present. If both callbacks were provided to
the \f(CW\*(C`watch_io\*(C'\fR method and only one is removed by this method, the other shall
remain.
.SS watch_signal
.IX Subsection "watch_signal"
.Vb 1
\&   $loop\->watch_signal( $signal, $code );
.Ve
.PP
This method adds a new signal handler to watch the given signal.
.ie n .IP $signal 8
.el .IP \f(CW$signal\fR 8
.IX Item "$signal"
The name of the signal to watch to. This should be a bare name like \f(CW\*(C`TERM\*(C'\fR.
.ie n .IP $code 8
.el .IP \f(CW$code\fR 8
.IX Item "$code"
A CODE reference to the handling callback.
.PP
There can only be one callback per signal name. Registering a new one will
remove an existing one.
.PP
Applications should use a IO::Async::Signal object, or call
\&\f(CW\*(C`attach_signal\*(C'\fR instead of using this method.
.PP
This and \f(CW\*(C`unwatch_signal\*(C'\fR are optional; a subclass may implement neither, or
both. If it implements neither then signal handling will be performed by the
base class using a self-connected pipe to interrupt the main IO blocking.
.SS unwatch_signal
.IX Subsection "unwatch_signal"
.Vb 1
\&   $loop\->unwatch_signal( $signal );
.Ve
.PP
This method removes the signal callback for the given signal.
.ie n .IP $signal 8
.el .IP \f(CW$signal\fR 8
.IX Item "$signal"
The name of the signal to watch to. This should be a bare name like \f(CW\*(C`TERM\*(C'\fR.
.SS watch_time
.IX Subsection "watch_time"
.Vb 1
\&   $id = $loop\->watch_time( %args );
.Ve
.PP
This method installs a callback which will be called at the specified time.
The time may either be specified as an absolute value (the \f(CW\*(C`at\*(C'\fR key), or
as a delay from the time it is installed (the \f(CW\*(C`after\*(C'\fR key).
.PP
The returned \f(CW$id\fR value can be used to identify the timer in case it needs
to be cancelled by the \f(CW\*(C`unwatch_time\*(C'\fR method. Note that this value may be
an object reference, so if it is stored, it should be released after it has
been fired or cancelled, so the object itself can be freed.
.PP
The \f(CW%params\fR hash takes the following keys:
.IP "at => NUM" 8
.IX Item "at => NUM"
The absolute system timestamp to run the event.
.IP "after => NUM" 8
.IX Item "after => NUM"
The delay after now at which to run the event, if \f(CW\*(C`at\*(C'\fR is not supplied. A
zero or negative delayed timer should be executed as soon as possible; the
next time the \f(CW\*(C`loop_once\*(C'\fR method is invoked.
.IP "now => NUM" 8
.IX Item "now => NUM"
The time to consider as now if calculating an absolute time based on \f(CW\*(C`after\*(C'\fR;
defaults to \f(CWtime()\fR if not specified.
.IP "code => CODE" 8
.IX Item "code => CODE"
CODE reference to the continuation to run at the allotted time.
.PP
Either one of \f(CW\*(C`at\*(C'\fR or \f(CW\*(C`after\*(C'\fR is required.
.PP
For more powerful timer functionality as a IO::Async::Notifier (so it can
be used as a child within another Notifier), see instead the
IO::Async::Timer object and its subclasses.
.PP
These \f(CW*_time\fR methods are optional; a subclass may implement neither or both
of them. If it implements neither, then the base class will manage a queue of
timer events. This queue should be handled by the \f(CW\*(C`loop_once\*(C'\fR method
implemented by the subclass, using the \f(CW\*(C`_adjust_timeout\*(C'\fR and
\&\f(CW\*(C`_manage_queues\*(C'\fR methods.
.PP
This is the newer version of the API, replacing \f(CW\*(C`enqueue_timer\*(C'\fR. It is
unspecified how this method pair interacts with the older
\&\f(CW\*(C`enqueue/requeue/cancel_timer\*(C'\fR triplet.
.SS unwatch_time
.IX Subsection "unwatch_time"
.Vb 1
\&   $loop\->unwatch_time( $id )
.Ve
.PP
Removes a timer callback previously created by \f(CW\*(C`watch_time\*(C'\fR.
.PP
This is the newer version of the API, replacing \f(CW\*(C`cancel_timer\*(C'\fR. It is
unspecified how this method pair interacts with the older
\&\f(CW\*(C`enqueue/requeue/cancel_timer\*(C'\fR triplet.
.SS enqueue_timer
.IX Subsection "enqueue_timer"
.Vb 1
\&   $id = $loop\->enqueue_timer( %params );
.Ve
.PP
An older version of \f(CW\*(C`watch_time\*(C'\fR. This method should not be used in new code
but is retained for legacy purposes. For simple watch/unwatch behaviour use
instead the new \f(CW\*(C`watch_time\*(C'\fR method; though note it has differently-named
arguments. For requeueable timers, consider using an
IO::Async::Timer::Countdown or IO::Async::Timer::Absolute instead.
.SS cancel_timer
.IX Subsection "cancel_timer"
.Vb 1
\&   $loop\->cancel_timer( $id );
.Ve
.PP
An older version of \f(CW\*(C`unwatch_time\*(C'\fR. This method should not be used in new
code but is retained for legacy purposes.
.SS requeue_timer
.IX Subsection "requeue_timer"
.Vb 1
\&   $newid = $loop\->requeue_timer( $id, %params );
.Ve
.PP
Reschedule an existing timer, moving it to a new time. The old timer is
removed and will not be invoked.
.PP
The \f(CW%params\fR hash takes the same keys as \f(CW\*(C`enqueue_timer\*(C'\fR, except for the
\&\f(CW\*(C`code\*(C'\fR argument.
.PP
The requeue operation may be implemented as a cancel + enqueue, which may
mean the ID changes. Be sure to store the returned \f(CW$newid\fR value if it is
required.
.PP
This method should not be used in new code but is retained for legacy
purposes. For requeueable, consider using an IO::Async::Timer::Countdown or
IO::Async::Timer::Absolute instead.
.SS watch_idle
.IX Subsection "watch_idle"
.Vb 1
\&   $id = $loop\->watch_idle( %params );
.Ve
.PP
This method installs a callback which will be called at some point in the near
future.
.PP
The \f(CW%params\fR hash takes the following keys:
.IP "when => STRING" 8
.IX Item "when => STRING"
Specifies the time at which the callback will be invoked. See below.
.IP "code => CODE" 8
.IX Item "code => CODE"
CODE reference to the continuation to run at the allotted time.
.PP
The \f(CW\*(C`when\*(C'\fR parameter defines the time at which the callback will later be
invoked. Must be one of the following values:
.IP later 8
.IX Item "later"
Callback is invoked after the current round of IO events have been processed
by the loop's underlying \f(CW\*(C`loop_once\*(C'\fR method.
.Sp
If a new idle watch is installed from within a \f(CW\*(C`later\*(C'\fR callback, the
installed one will not be invoked during this round. It will be deferred for
the next time \f(CW\*(C`loop_once\*(C'\fR is called, after any IO events have been handled.
.PP
If there are pending idle handlers, then the \f(CW\*(C`loop_once\*(C'\fR method will use a
zero timeout; it will return immediately, having processed any IO events and
idle handlers.
.PP
The returned \f(CW$id\fR value can be used to identify the idle handler in case it
needs to be removed, by calling the \f(CW\*(C`unwatch_idle\*(C'\fR method. Note this value
may be a reference, so if it is stored it should be released after the
callback has been invoked or cancled, so the referrant itself can be freed.
.PP
This and \f(CW\*(C`unwatch_idle\*(C'\fR are optional; a subclass may implement neither, or
both. If it implements neither then idle handling will be performed by the
base class, using the \f(CW\*(C`_adjust_timeout\*(C'\fR and \f(CW\*(C`_manage_queues\*(C'\fR methods.
.SS unwatch_idle
.IX Subsection "unwatch_idle"
.Vb 1
\&   $loop\->unwatch_idle( $id );
.Ve
.PP
Cancels a previously-installed idle handler.
.SS watch_process
.IX Subsection "watch_process"
.Vb 1
\&   $loop\->watch_process( $pid, $code );
.Ve
.PP
This method adds a new handler for the termination of the given child process
PID, or all child processes.
.ie n .IP $pid 8
.el .IP \f(CW$pid\fR 8
.IX Item "$pid"
The PID to watch. Will report on all child processes if this is 0.
.ie n .IP $code 8
.el .IP \f(CW$code\fR 8
.IX Item "$code"
A CODE reference to the exit handler. It will be invoked as
.Sp
.Vb 1
\&   $code\->( $pid, $? )
.Ve
.Sp
The second argument is passed the plain perl \f(CW$?\fR value.
.PP
After invocation, the handler for a PID-specific watch is automatically
removed. The all-child watch will remain until it is removed by
\&\f(CW\*(C`unwatch_process\*(C'\fR.
.PP
This and \f(CW\*(C`unwatch_process\*(C'\fR are optional; a subclass may implement neither, or
both. If it implements neither then child watching will be performed by using
\&\f(CW\*(C`watch_signal\*(C'\fR to install a \f(CW\*(C`SIGCHLD\*(C'\fR handler, which will use \f(CW\*(C`waitpid\*(C'\fR to
look for exited child processes.
.PP
If both a PID-specific and an all-process watch are installed, there is no
ordering guarantee as to which will be called first.
.PP
\&\fBNOTE\fR that not all loop classes may be able to support the all-child watch.
The basic Select and Poll-based classes provided by this distribution do, and
those built on top of similar OS-specific mechanisms such as Linux's Epoll
probably will, but typically those built on top of other event systems such
as \fIglib\fR or \fIlibuv\fR may not be able, as the underlying event system may not
provide the necessary hooks to support it.
.SS unwatch_process
.IX Subsection "unwatch_process"
.Vb 1
\&   $loop\->unwatch_process( $pid );
.Ve
.PP
This method removes a watch on an existing child process PID.
.SH "METHODS FOR SUBCLASSES"
.IX Header "METHODS FOR SUBCLASSES"
The following methods are provided to access internal features which are
required by specific subclasses to implement the loop functionality. The use
cases of each will be documented in the above section.
.SS _adjust_timeout
.IX Subsection "_adjust_timeout"
.Vb 1
\&   $loop\->_adjust_timeout( \e$timeout );
.Ve
.PP
Shortens the timeout value passed in the scalar reference if it is longer in
seconds than the time until the next queued event on the timer queue. If there
are pending idle handlers, the timeout is reduced to zero.
.SS _manage_queues
.IX Subsection "_manage_queues"
.Vb 1
\&   $loop\->_manage_queues;
.Ve
.PP
Checks the timer queue for callbacks that should have been invoked by now, and
runs them all, removing them from the queue. It also invokes all of the
pending idle handlers. Any new idle handlers installed by these are not
invoked yet; they will wait for the next time this method is called.
.SH EXTENSIONS
.IX Header "EXTENSIONS"
An Extension is a Perl module that provides extra methods in the
\&\f(CW\*(C`IO::Async::Loop\*(C'\fR or other packages. They are intended to provide extra
functionality that easily integrates with the rest of the code.
.PP
Certain base methods take an \f(CW\*(C`extensions\*(C'\fR parameter; an ARRAY reference
containing a list of extension names. If such a list is passed to a method, it
will immediately call a method whose name is that of the base method, prefixed
by the first extension name in the list, separated by \f(CW\*(C`_\*(C'\fR. If the
\&\f(CW\*(C`extensions\*(C'\fR list contains more extension names, it will be passed the
remaining ones in another \f(CW\*(C`extensions\*(C'\fR parameter.
.PP
For example,
.PP
.Vb 4
\&   $loop\->connect(
\&      extensions => [qw( FOO BAR )],
\&      %args
\&   );
.Ve
.PP
will become
.PP
.Vb 4
\&   $loop\->FOO_connect(
\&      extensions => [qw( BAR )],
\&      %args
\&   );
.Ve
.PP
This is provided so that extension modules, such as IO::Async::SSL can
easily be invoked indirectly, by passing extra arguments to \f(CW\*(C`connect\*(C'\fR methods
or similar, without needing every module to be aware of the \f(CW\*(C`SSL\*(C'\fR extension.
This functionality is generic and not limited to \f(CW\*(C`SSL\*(C'\fR; other extensions may
also use it.
.PP
The following methods take an \f(CW\*(C`extensions\*(C'\fR parameter:
.PP
.Vb 2
\&   $loop\->connect
\&   $loop\->listen
.Ve
.PP
If an extension \f(CW\*(C`listen\*(C'\fR method is invoked, it will be passed a \f(CW\*(C`listener\*(C'\fR
parameter even if one was not provided to the original \f(CW\*(C`$loop\->listen\*(C'\fR
call, and it will not receive any of the \f(CW\*(C`on_*\*(C'\fR event callbacks. It should
use the \f(CW\*(C`acceptor\*(C'\fR parameter on the \f(CW\*(C`listener\*(C'\fR object.
.SH "STALL WATCHDOG"
.IX Header "STALL WATCHDOG"
A well-behaved IO::Async program should spend almost all of its time
blocked on input using the underlying \f(CW\*(C`IO::Async::Loop\*(C'\fR instance. The stall
watchdog is an optional debugging feature to help detect CPU spinlocks and
other bugs, where control is not returned to the loop every so often.
.PP
If the watchdog is enabled and an event handler consumes more than a given
amount of real time before returning to the event loop, it will be interrupted
by printing a stack trace and terminating the program. The watchdog is only in
effect while the loop itself is not blocking; it won't fail simply because the
loop instance is waiting for input or timers.
.PP
It is implemented using \f(CW\*(C`SIGALRM\*(C'\fR, so if enabled, this signal will no longer
be available to user code. (Though in any case, most uses of \f(CWalarm()\fR and
\&\f(CW\*(C`SIGALRM\*(C'\fR are better served by one of the IO::Async::Timer subclasses).
.PP
The following environment variables control its behaviour.
.IP "IO_ASYNC_WATCHDOG => BOOL" 4
.IX Item "IO_ASYNC_WATCHDOG => BOOL"
Enables the stall watchdog if set to a non-zero value.
.IP "IO_ASYNC_WATCHDOG_INTERVAL => INT" 4
.IX Item "IO_ASYNC_WATCHDOG_INTERVAL => INT"
Watchdog interval, in seconds, to pass to the \f(CWalarm(2)\fR call. Defaults to 10
seconds.
.IP "IO_ASYNC_WATCHDOG_SIGABRT => BOOL" 4
.IX Item "IO_ASYNC_WATCHDOG_SIGABRT => BOOL"
If enabled, the watchdog signal handler will raise a \f(CW\*(C`SIGABRT\*(C'\fR, which usually
has the effect of breaking out of a running program in debuggers such as
\&\fIgdb\fR. If not set then the process is terminated by throwing an exception with
\&\f(CW\*(C`die\*(C'\fR.
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
