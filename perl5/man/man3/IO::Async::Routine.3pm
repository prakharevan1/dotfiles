.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.0102 (Pod::Simple 3.45)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "IO::Async::Routine 3pm"
.TH IO::Async::Routine 3pm 2025-03-06 "perl v5.40.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
"IO::Async::Routine" \- execute code in an independent sub\-process or thread
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 2
\&   use IO::Async::Routine;
\&   use IO::Async::Channel;
\&
\&   use IO::Async::Loop;
\&   my $loop = IO::Async::Loop\->new;
\&
\&   my $nums_ch = IO::Async::Channel\->new;
\&   my $ret_ch  = IO::Async::Channel\->new;
\&
\&   my $routine = IO::Async::Routine\->new(
\&      channels_in  => [ $nums_ch ],
\&      channels_out => [ $ret_ch ],
\&
\&      code => sub {
\&         my @nums = @{ $nums_ch\->recv };
\&         my $ret = 0; $ret += $_ for @nums;
\&
\&         # Can only send references
\&         $ret_ch\->send( \e$ret );
\&      },
\&
\&      on_finish => sub {
\&         say "The routine aborted early \- $_[\-1]";
\&         $loop\->stop;
\&      },
\&   );
\&
\&   $loop\->add( $routine );
\&
\&   $nums_ch\->send( [ 10, 20, 30 ] );
\&   $ret_ch\->recv(
\&      on_recv => sub {
\&         my ( $ch, $totalref ) = @_;
\&         say "The total of 10, 20, 30 is: $$totalref";
\&         $loop\->stop;
\&      }
\&   );
\&
\&   $loop\->run;
.Ve
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This IO::Async::Notifier contains a body of code and executes it in a
sub-process or thread, allowing it to act independently of the main program.
Once set up, all communication with the code happens by values passed into or
out of the Routine via IO::Async::Channel objects.
.PP
The code contained within the Routine is free to make blocking calls without
stalling the rest of the program. This makes it useful for using existing code
which has no option not to block within an IO::Async\-based program.
.PP
To create asynchronous wrappers of functions that return a value based only on
their arguments, and do not generally maintain state within the process it may
be more convenient to use an IO::Async::Function instead, which uses an
\&\f(CW\*(C`IO::Async::Routine\*(C'\fR to contain the body of the function and manages the
Channels itself.
.SS Models
.IX Subsection "Models"
A choice of detachment model is available. Each has various advantages and
disadvantages. Not all of them may be available on a particular system.
.PP
\fIThe \fR\f(CI\*(C`fork\*(C'\fR\fI model\fR
.IX Subsection "The fork model"
.PP
The code in this model runs within its own process, created by calling
\&\f(CWfork()\fR from the main process. It is isolated from the rest of the program
in terms of memory, CPU time, and other resources. Because it is started
using \f(CWfork()\fR, the initial process state is a clone of the main process.
.PP
This model performs well on UNIX-like operating systems which possess a true
native \f(CWfork()\fR system call, but is not available on \f(CW\*(C`MSWin32\*(C'\fR for example,
because the operating system does not provide full fork-like semantics.
.PP
\fIThe \fR\f(CI\*(C`thread\*(C'\fR\fI model\fR
.IX Subsection "The thread model"
.PP
The code in this model runs inside a separate thread within the main process.
It therefore shares memory and other resources such as open filehandles with
the main thread. As with the \f(CW\*(C`fork\*(C'\fR model, the initial thread state is cloned
from the main controlling thread.
.PP
This model is only available on perls built to support threading.
.PP
\fIThe \fR\f(CI\*(C`spawn\*(C'\fR\fI model\fR
.IX Subsection "The spawn model"
.PP
\&\fISince version 0.79.\fR
.PP
The code in this model runs within its own freshly-created process running
another copy of the perl interpreter. Similar to the \f(CW\*(C`fork\*(C'\fR model it
therefore has its own memory, CPU time, and other resources. However, since it
is started freshly rather than by cloning the main process, it starts up in a
clean state, without any shared resources from its parent.
.PP
Since this model creates a new fresh process rather than sharing existing
state, it cannot use the \f(CW\*(C`code\*(C'\fR argument to specify the routine body; it must
instead use only the \f(CW\*(C`module\*(C'\fR and \f(CW\*(C`func\*(C'\fR arguments.
.PP
In the current implementation this model requires exactly one input channel
and exactly one output channel; both must be present, and there cannot be more
than one of either.
.SH EVENTS
.IX Header "EVENTS"
.ie n .SS "on_finish $exitcode"
.el .SS "on_finish \f(CW$exitcode\fP"
.IX Subsection "on_finish $exitcode"
For \f(CWfork()\fR\-based Routines, this is invoked after the process has exited and
is passed the raw exitcode status.
.ie n .SS "on_finish $type, @result"
.el .SS "on_finish \f(CW$type\fP, \f(CW@result\fP"
.IX Subsection "on_finish $type, @result"
For thread-based Routines, this is invoked after the thread has returned from
its code block and is passed the \f(CW\*(C`on_joined\*(C'\fR result.
.PP
As the behaviour of these events differs per model, it may be more convenient
to use \f(CW\*(C`on_return\*(C'\fR and \f(CW\*(C`on_die\*(C'\fR instead.
.ie n .SS "on_return $result"
.el .SS "on_return \f(CW$result\fP"
.IX Subsection "on_return $result"
Invoked if the code block returns normally. Note that \f(CWfork()\fR\-based Routines
can only transport an integer result between 0 and 255, as this is the actual
\&\f(CWexit()\fR value.
.ie n .SS "on_die $exception"
.el .SS "on_die \f(CW$exception\fP"
.IX Subsection "on_die $exception"
Invoked if the code block fails with an exception.
.SH PARAMETERS
.IX Header "PARAMETERS"
The following named parameters may be passed to \f(CW\*(C`new\*(C'\fR or \f(CW\*(C`configure\*(C'\fR:
.SS "model => ""fork"" | ""thread"" | ""spawn"""
.IX Subsection "model => ""fork"" | ""thread"" | ""spawn"""
Optional. Defines how the routine will detach itself from the main process.
See the "Models" section above for more detail.
.PP
If the model is not specified, the environment variable
\&\f(CW\*(C`IO_ASYNC_ROUTINE_MODEL\*(C'\fR is used to pick a default. If that isn't defined,
\&\f(CW\*(C`fork\*(C'\fR is preferred if it is available, otherwise \f(CW\*(C`thread\*(C'\fR.
.SS "channels_in => ARRAY of IO::Async::Channel"
.IX Subsection "channels_in => ARRAY of IO::Async::Channel"
ARRAY reference of IO::Async::Channel objects to set up for passing values
in to the Routine.
.SS "channels_out => ARRAY of IO::Async::Channel"
.IX Subsection "channels_out => ARRAY of IO::Async::Channel"
ARRAY reference of IO::Async::Channel objects to set up for passing values
out of the Routine.
.SS "code => CODE"
.IX Subsection "code => CODE"
CODE reference to the body of the Routine, to execute once the channels are
set up.
.PP
When using the \f(CW\*(C`spawn\*(C'\fR model, this is not permitted; you must use \f(CW\*(C`module\*(C'\fR
and \f(CW\*(C`func\*(C'\fR instead.
.SS "module => STRING"
.IX Subsection "module => STRING"
.SS "func => STRING"
.IX Subsection "func => STRING"
\&\fISince version 0.79.\fR
.PP
An alternative to the \f(CW\*(C`code\*(C'\fR argument, which names a module to load and a
function to call within it. \f(CW\*(C`module\*(C'\fR should give a perl module name (i.e.
\&\f(CW\*(C`Some::Name\*(C'\fR, not a filename like \fISome/Name.pm\fR), and \f(CW\*(C`func\*(C'\fR should give
the basename of a function within that module (i.e. without the module name
prefixed). It will be invoked as the main code body of the object, and passed
in a list of all the channels; first the input ones then the output ones.
.PP
.Vb 1
\&   module::func( @channels_in, @channels_out );
.Ve
.SS "setup => ARRAY"
.IX Subsection "setup => ARRAY"
Optional. For \f(CWfork()\fR\-based Routines, gives a reference to an array to pass
to the underlying \f(CW\*(C`Loop\*(C'\fR \f(CW\*(C`fork_child\*(C'\fR method. Ignored for thread-based
Routines.
.SH METHODS
.IX Header "METHODS"
.SS id
.IX Subsection "id"
.Vb 1
\&   $id = $routine\->id;
.Ve
.PP
Returns an ID string that uniquely identifies the Routine out of all the
currently-running ones. (The ID of already-exited Routines may be reused,
however.)
.SS model
.IX Subsection "model"
.Vb 1
\&   $model = $routine\->model;
.Ve
.PP
Returns the detachment model in use by the Routine.
.SS kill
.IX Subsection "kill"
.Vb 1
\&   $routine\->kill( $signal );
.Ve
.PP
Sends the specified signal to the routine code. This is either implemented by
\&\f(CWCORE::kill()\fR or \f(CW\*(C`threads::kill\*(C'\fR as required. Note that in the thread case
this has the usual limits of signal delivery to threads; namely, that it works
at the Perl interpreter level, and cannot actually interrupt blocking system
calls.
.SS result_future
.IX Subsection "result_future"
.Vb 1
\&   $f = $routine\->result_future;
.Ve
.PP
\&\fISince version 0.75.\fR
.PP
Returns a new \f(CW\*(C`IO::Async::Future\*(C'\fR which will complete with the eventual
return value or exception when the routine finishes.
.PP
If the routine finishes with a successful result then this will be the \f(CW\*(C`done\*(C'\fR
result of the future. If the routine fails with an exception then this will be
the \f(CW\*(C`fail\*(C'\fR result.
.SH AUTHOR
.IX Header "AUTHOR"
Paul Evans <leonerd@leonerd.org.uk>
